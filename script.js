const STORAGE_KEY = "tangoChoWords";
const APP_VERSION = "v37";

const HF_BASE_KEY = "tangoChoHfBase";
const HF_TOKEN_KEY = "tangoChoAppToken";
const DEFAULT_HF_BASE = "https://mazzgogo-tango-cho.hf.space";

const FILTER_KEY = "tangoChoFilter";
const SORT_KEY = "tangoChoSort";
const TAG_FILTER_KEY = "tangoChoTagFilter";
const DIFF_CAP_KEY = "tangoChoDifficultyCap";
const STUDY_HIST_KEY = "tangoChoStudyHist";
const FORTUNE_MANUAL_KEY = "tangoChoFortuneLevelManual";

let editId = null;

const STATUS_LABEL = {
  forgot: "覚えてない",
  default: "デフォルト",
  learned: "覚えた",
};

// --- Quiz SFX (no external audio files) ---
// iOS (Safari/PWA) can be picky about WebAudio. We keep WebAudio, and add a tiny
// HTMLAudio (data: WAV) fallback for iPhone/iPad only. (No UI changes.)
const __IS_IOS = (() => {
  const ua = navigator.userAgent || "";
  const iOS = /iPad|iPhone|iPod/.test(ua);
  const iPadOS13 = (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  return iOS || iPadOS13;
})();

// Small embedded WAVs (data URI) for iOS fallback.
const __PING_WAV = "data:audio/wav;base64,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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAPwCLAO0AXgHXAUwCtQIIAzsDRwMmA9QCUAKaAbcArv+H/k79D/za+rz5xvgE+IX3Ufdy9+v3v/jq+Wb7KP0k/0cBgAO4BdkHzQl9C9YMxQ09DjMOoA2GDOgK0AhOBnUDXAAh/d/5tvbF8yrxAe9j7WXsFOx77JvtcO/v8QX1m/iS/McAFgVXCWENDhE4FL0WghhwGXoZmRjPFicUsxCPDNwHwwJy/Rf45PIK7rnpG+ZW44nhyuAl4Z3iLOW+6DrtefJR+I3+9gRUC2kR/hbcG9IfuSJvJOAkAiTVIWke1xlEFN4N3QZ+/wP4sPDJ6Y/jP94N2iTXpNWg1SDXG9p83iDk2upv8qf6DwNdC0MTfBrGIOglsykGLMws/SuhKc0lpCBUGhcTLQveAnf6QPKF6o3jld3U2HXVldNH043UW9eX2x3huecx70D3nv//BxkQoRdUHvUjUihCK6wsgizHKoon5yIKHSYWeg5MBuX9kfWb7Uvm49+d2qnWKtQ209fTB9ax2bbe5+QM7ObzLfyWBNYMohS0G8whsyY8KkgsxCysKwop9SSTHxMZsRGwCVcB8vjN8DDpYuKf3BzYANVp02TT89QF2IHcPeIG6Z/wwvgmAYAJhBHrGHAf2iT2KKErwixPLEwqyybsIdsbzhQFDccEXvwV9DjsDuXX3svZGNbf0zXTINSW1oLawd8j5m7tYvW1/RsGTA77FeQcyCJzJ7kqfSyvLE8rZygSJHgeyxdHEC8Iz/9w917v4udA4bTbb9eZ1ErTj9Nl1bzYdt1n41rqEfJG+q0C/grrEi0agyCzJY8p9CvMLA8sxSkCJucgpBpvE4wLQAPY+p3y3OrZ49TdBNmU1aPTQtN11DLXX9vW4Gfn1u7g9jz/nwe9D04XDB66IyYoKCukLI0s5Cq3JyQjVB17FtcOrQZH/vH19e2c5ijg1NrP1j7UONPH0+XVf9l03pnkteuI88z7NAR4DEsUZxuMIYEmGyo5LMgswisxKSwl2B9kGQsSDwq5AVP5KfGF6azi3NxJ2BzVc9Nc09jU2tdG3PThsuhD8GH4xAAgCSoRmRgqH6EkziiLK74sXSxsKvwmLCInHCQVYw0oBcD8dPSR7FzlGd/+2TvW8dM00wzUcdZN2n3f0+UV7QL1U/26Be8NphWZHIoiRCebKnEstixnK5EoTCTAHh4YohCQCDEA0fe57zXoiOHu25nXsdRR04PTR9WN2DjdHOMF6rTx5flLAp4KkhLdGT8gfiVqKeAryywhLOgpNSYpIfIayBPrC6IDOfv78jLrJeQU3jXZtNWx0z7TX9QK1ybbkOAV53zugPba/j4HYQ/6FsMdfyP7Jw0rnCyXLAAr5CdhI54d0BYzDw4Hqf5Q9k/u7eZt4Avb9tZU1DzTuNPE1U3ZNN5M5F7rKvNq+9MDGgz0ExkbSiFPJvkpKSzKLNYrVyljJR0gtRllEm8KGwK0+Ybx2un24hnddtg51X7TVNO+1K7XC9ys4V/o5+8B+GIAwAjPEEcY4x5pJKUocyu5LGssiyosJ2sicxx7FcANiQUi/dP06eys5VzfM9pf1gPUNNP6003WGNo634Tlveyj9PH8WQWRDVAVTRxMIhQnfCpkLLwsfyu6KIUkBx9wGP0Q8AiTADH4FfCJ6NDhKNzE18vUWNN40yrVX9j63NHisOlX8YT56gE/CjgSjRn7H0glRCnMK8ksMSwKKmgmayFAGx8USQwEBJv7WfOJ63LkVN5m2dTVv9M600nU4tbv2krgxOYi7iD2eP7dBgUPpRZ5HUMjzifyKpIsoCwbKxEonSPnHSQXjw9uBwv/sPap7j7ns+BC2x7XatRA06nTpNUc2fTd/+MH68zyCftxA7sLnBPLGgghGybXKRgsyyzqK30pmCVhIAUavhLOCnwCFfrj8S/qQeNX3aXYVtWJ003TpdSE19HbZOEM6IzvoPcAAGAIdBD0F5weLyR8KFsrsyx3LKoqWyepIr8c0RUdDusFhP0y9ULt++Wf32jag9YW1DXT6NMp1uXZ+N415WTsRfSP/PcENA35FAEcDCLkJlwqVyzALJYr4ii+JE0fwhhXEVAJ9QCS+HHw3OgZ4mPc79fl1GDTbtMO1TLYvdyH4lvp+/Aj+YgB4AneETwZth8RJR4ptyvGLEEsLCqaJqwhjht3FKcMZQT8+7fz4evA5JXemNn21c/TN9M01LzWuNoF4HPmyO3B9Rb+fAapDlAWLx0GI6En1iqILKgsNSs8KNgjMB53F+sPzwdt/xD3A++Q5/nge9tG14HURNOc04TV7Ni03bPjsOpv8qf6DwNdC0MTfBrGIOglsykGLMws/SuhKc0lpCBUGhcTLQveAnf6QPKF6o3jld3U2HXVldNH043UW9eX2x3huecx70D3nv//BxkQoRdUHvUjUihCK6wsgizHKoon5yIKHSYWeg5MBuX9kfWb7Uvm49+d2qnWKtQ209fTB9ax2bbe5+QM7ObzLfyWBNYMohS0G8whsyY8KkgsxCysKwop9SSTHxMZsRGwCVcB8vjN8DDpYuKf3BzYANVp02TT89QF2IHcPeIG6Z/wwvgmAYAJhBHrGHAf2iT2KKErwixPLEwqyybsIdsbzhQFDccEXvwV9DjsDuXX3svZGNbf0zXTINSW1oLawd8j5m7tYvW1/RsGTA77FeQcyCJzJ7kqfSyvLE8rZygSJHgeyxdHEC8Iz/9w917v4udA4bTbb9eZ1ErTj9Nl1bzYdt1n41rqEfJG+q0C/grrEi0agyCzJY8p9CvMLA8sxSkCJucgpBpvE4wLQAPY+p3y3OrZ49TdBNmU1aPTQtN11DLXX9vW4Gfn1u7g9jz/nwe9D04XDB66IyYoKCukLI0s5Cq3JyQjVB17FtcOrQZH/vH19e2c5ijg1NrP1j7UONPH0+XVf9l03pnkteuI88z7NAR4DEsUZxuMIYEmGyo5LMgswisxKSwl2B9kGQsSDwq5AVP5KfGF6azi3NxJ2BzVc9Nc09jU2tdG3PThsuhD8GH4xAAgCSoRmRgqH6EkziiLK74sXSxsKvwmLCInHCQVYw0oBcD8dPSR7FzlGd/+2TvW8dM00wzUcdZN2n3f0+UV7QL1U/26Be8NphWZHIoiRCebKnEstixnK5EoTCTAHh4YohCQCDEA0fe57zXoiOHu25nXsdRR04PTR9WN2DjdHOMF6rTx5flLAp4KkhLdGT8gfiVqKeAryywhLOgpNSYpIfIayBPrC6IDOfv78jLrJeQU3jXZtNWx0z7TX9QK1ybbkOAV53zugPba/j4HYQ/6FsMdfyP7Jw0rnCyXLAAr5CdhI54d0BYzDw4Hqf5Q9k/u7eZt4Avb9tZU1DzTuNPE1U3ZNN5M5F7rKvNq+9MDGgz0ExkbSiFPJvkpKSzKLNYrVyljJR0gtRllEm8KGwK0+Ybx2un24hnddtg51X7TVNO+1K7XC9ys4V/o5+8B+GIAwAjPEEcY4x5pJKUocyu5LGssiyosJ2sicxx7FcANiQUi/dP06eys5VzfM9pf1gPUNNP6003WGNo634Tlveyj9PH8WQWRDVAVTRxMIhQnfCpkLLwsfyu6KIUkBx9wGP0Q8AiTADH4FfCJ6NDhKNzE18vUWNN40yrVX9j63NHisOlX8YT56gE/CjgSjRn7H0glRCnMK8ksMSwKKmgmayFAGx8USQwEBJv7WfOJ63LkVN5m2dTVv9M600nU4tbv2krgxOYi7iD2eP7dBgUPpRZ5HUMjzifyKpIsoCwbKxEonSPnHSQXjw9uBwv/sPap7j7ns+BC2x7XatRA06nTpNUc2fTd/+MH68zyCftxA7sLnBPLGgghGybXKRgsyyzqK30pmCVhIAUavhLOCnwCFfrj8S/qQeNX3aXYVtWJ003TpdSE19HbZOEM6IzvoPcAAGAIdBD0F5weLyR8KFsrsyx3LKoqWyepIr8c0RUdDusFhP0y9ULt++Wf32jag9YW1DXT6NMp1uXZ+N415WTsRfSP/PcENA35FAEcDCLkJlwqVyzALJYr4ii+JE0fwhhXEVAJ9QCS+HHw3OgZ4mPc79fl1GDTbtMO1TLYvdyH4lvp+/Aj+YgB4AneETwZth8RJR4ptyvGLEEsLCqaJqwhjht3FKcMZQT8+7fz4evA5JXemNn21c/TN9M01LzWuNoF4HPmyO3B9Rb+fAapDlAWLx0GI6En1iqILKgsNSs8KNgjMB53F+sPzwdt/xD3A++Q5/nge9tG14HURNOc04TV7Ni03bPjsOpv8qf6DwNdC0MTfBrGIOglsykGLMws/SuhKc0lpCBUGhcTLQveAnf6QPKF6o3jld3U2HXVldNH043UW9eX2x3huecx70D3nv//BxkQoRdUHvUjUihCK6wsgizHKoon5yIKHSYWeg5MBuX9kfWb7Uvm49+d2qnWKtQ209fTB9ax2bbe5+QM7ObzLfyWBNYMohS0G8whsyY8KkgsxCysKwop9SSTHxMZsRGwCVcB8vjN8DDpYuKf3BzYANVp02TT89QF2IHcPeIG6Z/wwvgmAYAJhBHrGHAf2iT2KKErwixPLEwqyybsIdsbzhQFDccEXvwV9DjsDuXX3svZGNbf0zXTINSW1oLawd8j5m7tYvW1/RsGTA77FeQcyCJzJ7kqfSyvLE8rZygSJHgeyxdHEC8Iz/9w917v4udA4bTbb9eZ1ErTj9Nl1bzYdt1n41rqEfJG+q0C/grrEi0agyCzJY8p9CvMLA8sxSkCJucgpBpvE4wLQAPY+p3y3OrZ49TdBNmU1aPTQtN11DLXX9vW4Gfn1u7g9jz/nwe9D04XDB66IyYoKCukLI0s5Cq3JyQjVB17FtcOrQZH/vH19e2c5ijg1NrP1j7UONPH0+XVf9l03pnkteuI88z7NAR4DEsUZxuMIYEmGyo5LMgswisxKSwl2B9kGQsSDwq5AVP5KfGF6azi3NxJ2BzVc9Nc09jU2tdG3PThsuhD8GH4xAAgCSoRmRgqH6EkziiLK74sXSxsKvwmLCInHCQVYw0oBcD8dPSR7FzlGd/+2TvW8dM00wzUcdZN2n3f0+UV7QL1U/26Be8NphWZHIoiRCebKnEstixnK5EoTCTAHh4YohCQCDEA0fe57zXoiOHu25nXsdRR04PTR9WN2DjdHOMF6rTx5flLAp4KkhLdGT8gfiVqKeAryywhLOgpNSYpIfIayBPrC6IDOfv78jLrJeQU3jXZtNWx0z7TX9QK1ybbkOAV53zugPba/j4HYQ/6FsMdfyP7Jw0rnCyXLAAr5CdhI54d0BYzDw4Hqf5Q9k/u7eZt4Avb9tZU1DzTuNPE1U3ZNN5M5F7rKvNq+9MDGgz0ExkbSiFPJvkpKSzKLNYrVyljJR0gtRllEm8KGwK0+Ybx2un24hnddtg51X7TVNO+1K7XC9ys4V/o5+8B+GIAwAjPEEcY4x5pJKUocyu5LGssiyosJ2sicxx7FcANiQUi/dP06eys5VzfM9pf1gPUNNP6003WGNo634Tlveyj9PH8WQWRDVAVTRxMIhQnfCpkLLwsfyu6KIUkBx9wGP0Q8AiTADH4FfCJ6NDhKNzE18vUWNN40yrVX9j63NHisOlX8YT56gE/CjgSjRn7H0glRCnMK8ksMSwKKmgmayFAGx8USQwEBJv7WfOJ63LkVN5m2dTVv9M600nU4tbv2krgxOYi7iD2eP7dBgUPpRZ5HUMjzifyKpIsoCwbKxEonSPnHSQXjw9uBwv/sPap7j7ns+BC2x7XatRA06nTpNUc2fTd/+MH68zyCftxA7sLnBPLGgghGybXKRgsyyzqK30pmCVhIAUavhLOCnwCFfrj8S/qQeNX3aXYVtWJ003TpdSE19HbZOEM6IzvoPcAAGAIdBD0F5weLyR8KFsrsyx3LKoqWyepIr8c0RUdDusFhP0y9ULt++Wf32jag9YW1DXT6NMp1uXZ+N415WTsRfSP/PcENA35FAEcDCLkJlwqVyzALJYr4ii+JE0fwhhXEVAJ9QCS+HHw3OgZ4mPc79fl1GDTbtMO1TLYvdyH4lvp+/Aj+YgB4AneETwZth8RJR4ptyvGLEEsLCqaJqwhjht3FKcMZQT8+7fz4evA5JXemNn21c/TN9M01LzWuNoF4HPmyO3B9Rb+fAapDlAWLx0GI6En1iqILKgsNSs8KNgjMB53F+sPzwdt/xD3A++Q5/nge9tG14HURNOc04TV7Ni03bPjsOpv8qf6DwNdC0MTfBrGIOglsykGLMws/SuhKc0lpCBUGhcTLQveAnf6QPKF6o3jld3U2HXVldNH043UW9eX2x3huecx70D3nv//BxkQoRdUHvUjUihCK6wsgizHKoon5yIKHSYWeg5MBuX9kfWb7Uvm49+d2qnWKtQ209fTB9ax2bbe5+QM7ObzLfyWBNYMohS0G8whsyY8KkgsxCysKwop9SSTHxMZsRGwCVcB8vjN8DDpYuKf3BzYANVp02TT89QF2IHcPeIG6Z/wwvgmAYAJhBHrGHAf2iT2KKErwixPLEwqyybsIdsbzhQFDccEXvwV9DjsDuXX3svZGNbf0zXTINSW1oLawd8j5m7tYvW1/RsGTA77FeQcyCJzJ7kqfSyvLE8rZygSJHgeyxdHEC8Iz/9w917v4udA4bTbb9eZ1ErTj9Nl1bzYdt1n41rqEfJG+q0C/grrEi0agyCzJY8p9CvMLA8sxSkCJucgpBpvE4wLQAPY+p3y3OrZ49TdBNmU1aPTQtN11DLXX9vW4Gfn1u7g9jz/nwe9D04XDB66IyYoKCukLI0s5Cq3JyQjVB17FtcOrQZH/vH19e2c5ijg1NrP1j7UONPH0+XVf9l03pnkteuI88z7NAR4DEsUZxuMIYEmGyo5LMgswisxKSwl2B9kGQsSDwq5AVP5KfGF6azi3NxJ2BzVc9Nc09jU2tdG3PThsuhD8GH4xAAgCSoRmRgqH6EkziiLK74sXSxsKvwmLCInHCQVYw0oBcD8dPSR7FzlGd/+2TvW8dM00wzUcdZN2n3f0+UV7QL1U/26Be8NphWZHIoiRCebKnEstixnK5EoTCTAHh4YohCQCDEA0fe57zXoiOHu25nXsdRR04PTR9WN2DjdHOMF6rTx5flLAp4KkhLdGT8gfiVqKeAryywhLOgpNSYpIfIayBPrC6IDOfv78jLrJeQU3jXZtNWx0z7TX9QK1ybbkOAV53zugPba/j4HYQ/6FsMdfyP7Jw0rnCyXLAAr5CdhI54d0BYzDw4Hqf5Q9k/u7eZt4Avb9tZU1DzTuNPE1U3ZNN5M5F7rKvNq+9MDGgz0ExkbSiFPJvkpKSzKLNYrVyljJR0gtRllEm8KGwK0+Ybx2un24hnddtg51X7TVNO+1K7XC9ys4V/o5+8B+GIAwAjPEEcY4x5pJKUocyu5LGssiyosJ2sicxx7FcANiQUi/dP06eys5VzfM9pf1gPUNNP6003WGNo634Tlveyj9PH8WQWRDVAVTRxMIhQnfCpkLLwsfyu6KIUkBx9wGP0Q8AiTADH4FfCJ6NDhKNzE18vUWNN40yrVX9j63NHisOlX8YT56gE/CjgSjRn7H0glRCnMK8ksMSwKKmgmayFAGx8USQwEBJv7WfOJ63LkVN5m2dTVv9M600nU4tbv2krgxOYi7iD2eP7dBgUPpRZ5HUMjzifyKpIsoCwbKxEonSPnHSQXjw9uBwv/sPap7j7ns+BC2x7XatRA06nTpNUc2fTd/+MH68zyCftxA7sLnBPLGgghGybXKRgsyyzqK30pmCVhIAUavhLOCnwCFfrj8S/qQeNX3aXYVtWJ003TpdSE19HbZOEM6IzvoPcAAGAIdBD0F5weLyR8KFsrsyx3LKoqWyepIr8c0RUdDusFhP0y9ULt++Wf32jag9YW1DXT6NMp1uXZ+N415WTsRfSP/PcENA35FAEcDCLkJlwqVyzALJYr4ii+JE0fwhhXEVAJ9QCS+HHw3OgZ4mPc79fl1GDTbtMO1TLYvdyH4lvp+/Aj+YgB4AneETwZth8RJR4ptyvGLEEsLCqaJqwhjht3FKcMZQT8+7fz4evA5JXemNn21c/TN9M01LzWuNoF4HPmyO3B9Rb+fAapDlAWLx0GI6En1iqILKgsNSs8KNgjMB53F+sPzwdt/xD3A++Q5/nge9tG14HURNOc04TV7Ni03bPjsOpv8qf6DwNdC0MTfBrGIOglsykGLMws/SuhKc0lpCBUGhMTKQvdAnv6TfKe6rPjyt0Y2cfV9NOv0/rUydcB3HzhCehr72D3oP/fB9QPOBfHHUcjhydgKroriSvPKZ0mDyJQHJQVGA4gBvX93vUm7hLn4uDN2wHYn9W81GDVhNcV2/Hf7eXR7GD0VfxmBE0MwxODGlEg+SRSKD0qqyqYKQ4nJCMAHs4XyRAuCUQBU/mh8XPqCuSh3mbagdcK1g7Wjdd42rTeG+R86pzxOvkSAd4IVxA5F0YdSiIVJogojCkYKTIn7CNiH8AZNxMEDGcEp/wI9c7tPOeM4fHclNmT1wDX39co2sXdleJt6BbvVvbq/YwF+gzwEy8afx+xI58mLyhUKA0nZyR5IGgbYhWdDlgH1f9V+B7xcOqH5Jnf0ttS2THYd9gh2iHdWuGl5tPsq/Pw+l4CtAmwEBIXoRwrIYgkmiZPJ6ImlyREIcYcRxf4EBIK1QKD+1v0n+2N51niNN5B25vZUNli2sfcaeAm5dPqPfEp+Fj/iQZ+DfUTtRmLHksi1CQQJvMlgSTGIdsd5RgRE5MMpwWL/oD3xPCV6irls+BZ3TnbZdrm2rXcwd/v4xjpDe+Y9X/8gANgCt8QwxbXG+0f4iKaJAclJiQAIqgePBrnFNcORAhqAYf61/OZ7QToSeOU3wXds9up2+fcYN//4qLnHu1C89b5ngBeB9gN0hMWGXYdySD0IuIjjCP1IS0fTRt5FtwQqgobBGr91PaT8OHq8OXs4freM92n3FrdRd9W4nLmcusp8WP35/17BOQK5xBPFusakh4jIYgitSKpIW4fGBzHF6ES1gyaBiUAtPl987vtoOhb5BHh4N7a3Qrea9/y4YflCOpN7yf1X/u9AQkICQ6HE1MYQRwtHwAhpyEfIWwfnxzQGCUUxQ7kCLUCcvxR9ovwU+vZ5kPjs+A/3/Le0N/Q4d/k4eiy7SXzCfkp/0wFPgvGELUV3RkaHU4fZyBbICsf4xyXGWcVdxD2ChUFCv8K+UzzA+5g6YzlqOLO4A/gcODu4Xrk/edW7F/x6fbC/LQCiwgSDhcTbRftGnkd+h5iH68e5xwcGmcW6hHODEEHdgGi+/f1qvDr6+Pnt+SD4lrhRuFH4lTkWec769bvAPWL+kIA9QVvC38Q9xSvGIcbZR04HvsdrxxhGicXHhNrDjgJtQMV/oj4QvNz7kTq2+ZY5M/iTuLa4mzk9uZg6ovuUvOI+P79ggPkCPMNgRJlFn4ZrhvkHBQdPhxpGqgXExTLD/cKwwVeAPr6xvXx8KfsDulG5mfkg+Og473kz+bE6X7t3vG69uf7NQF1BngLERAWFGMX2xlpG/4blxs3GusXyhTuEH0MnQd8Akn9MPhh8wfvSetI6B7m4OSX5EXl5OZk6a/spvAk9QL6E/8oBBUJrQ3HET4V8xfOGcAavxrOGfQXRBXVEcgNQQlqBG//fPq99V7xhu1X6u3nX+a45f/lMOdA6Rzsqe/H81H4Hf3/Ac0GWgt+DxMT+hUZGF0ZuxkxGcUXgxWAEtkOrgomBmoBpPwA+KfzwO9u7M/p+uf/5ubmr+dT6cPr5+6k8tb2WPsAAKUEHglBDekQ9xNOFtsXkBhmGGEXiRXxErAP4wuuBzcDp/4l+tz18PGH7r3rreln6PbnX+ic6aPrYO658ZH1xPkt/qEC/AYVC8YO8BF1FEEWQhdxF8wWWhUpE00Q4AwBCdQEfgAp/Pj3E/Sc8LLtcOvp6SrpOukX6rnrEO4I8YT0ZfiI/MUA+gT/CK8M6g+TEpMU1xVWFgsW+RQrE7IQpA0dCj4GKgIH/vf5Ifan8qnvP+2B633qPOq/6gLs+O2O8K7zO/cT+xX/GwMDB6kK6w2tENcSVRQaFSEVaRT6EuEQMQ4EC3UHpwO8/9X7GPik9JrxFO8p7errYOuR63rsEu5L8A/zRvbR+ZH9ZAEnBbgI+AvKDhMRwRLEExQUrxOYEtsQiA6zC3gI8wREAY/98fmN9oLz6vDc7mrtoeyI7B7tXu478KbyhvXC+D381v9tA+MGFwruDE0PIBFXEugSzhILEqUQqw4uDEYJDQagAiD/qvte+Fr1ufKS8Pnu+u2e7ent1u5e8HDy+/Tn9xn7df7aASwFTAgeC4oNeQ/bEKMRzBFUEUEQnA51DOAJ9AbMA4YAP/0T+h/3f/RI8pDwZe/Q7tfueO+u8G3ypPRA9yf6Qf1vAJcDmwZhCc8L0A1TD0oQrhB6ELIPXg6KDEYKqAfIBMABrP6n+8z4NPb48yvy3PAX8OPvQPAq8Znyf/TL9mj5Pfwx/ycCCQW6ByIKLAzGDeMOeA+AD/4O9A1uDHoKKgiSBcwC8P8X/Vv61ved9cTzW/Jv8QjxJ/HN8fHyivSJ9tr4afse/uAAmQMtBocIkQo5DHENLw5sDicOYw0mDH4KeggrBqgDBwFg/sv7X/kx91X13PPT8kHyK/KT8nPzw/R29n34xvo7/cX/TQK/BAIHBAmxCvwL2gxCDTMNrQy1C1UKmgiTBlQE8QGA/xf9y/qw+Nv2WvU79IjzRvN38xn0JfWS9lH4U/qG/NX+KgFzA5kFigc0CYkKfQsIDCYM1wsdCwAKiwjLBtAErQJ1ADz+FvwX+k/40Pal9dn0c/R29OH0r/XZ9lP4EfoB/BL+MQBMAk4EJwbGBxwJHQrDCgYL5gpjCoQJUQjUBh0FOgM9ATn/Pv1g+675OPgK9y/2rfWK9cX1XPZI94L4/fmr+379ZP9MASYD4ARrBroHwQh3CdcJ3gmMCeQI7QexBjsFmAPYAQoAQP6I/PP6jvll+IP37/au9sH2J/fd99r4FfqE+xj9xP52ACICuAMpBWkGbAcrCJ8IxAibCCQIZAdkBiwFyANFArAAGf+N/Rr8zfqy+dH4M/jd99D3DviS+Fj5WfqK++D8UP7M/0YBsgIDBCwFJAbjBmMHngeVB0cHuQbvBfIEywOEAikByP9s/iD98vvr+hT6dfkS+e74Cvll+fr5xPq7+9b8C/5O/5QA0gH8AgkE7gSlBScGcQaABlQG7wVXBZAEogOWAnUBSgAh/wP++fwN/Ej7r/pH+hX6GPpQ+rv6VPsV/Pf88v38/gwAGQEYAgIDzgN1BPIEQQVgBU4FDAWeBAgETwN7ApQBoQCt/77+3v0U/Wb83Pt4+z/7MvtP+5f7BfyV/EL9Bv7Y/rH/iQBaARwCxwJYA8cDFAQ6BDoEEwTJA14D1gI3AocBzAANAFH/nv77/Wz9+Pyg/Gn8U/xe/Ir81Pw5/bX9RP7f/oL/JQDEAFkB3wFSAq0C7gIUAx0DCgPcApUCOQLKAU4BygBBALr/OP/A/lb+/v26/Yz9dv13/Y/9vP38/U3+q/4S/3//7f9XALwAGAFnAacB1QHyAfwB9AHbAbIBewE4Ae0AnABJAPf/qP9f/x//6v7B/qT+lv6V/qH+uf7b/gb/OP9u/6f/4P8VAEgAdQCbALkAzgDaAN0A2ADLALgAoACDAGQARAAlAAgA7v/Y/8X/uP+w/63/rv+z/7v/xv/R/93/6f/z//r///8=";
const __BUZZ_WAV = "data:audio/wav;base64,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";

function __playHtmlAudio(src, vol=1.0) {
  try {
    const a = new Audio(src);
    a.preload = "auto";
    a.volume = vol;
    // Ensure starts from head even on rapid taps
    a.currentTime = 0;
    const p = a.play();
    if (p && typeof p.catch === "function") p.catch(() => {});
  } catch (e) {}
}

let __htmlPrimed = false;
function __primeHtmlAudioOnce() {
  if (__htmlPrimed) return;
  __htmlPrimed = true;
  // Prime HTMLAudio on first gesture (silent/near-silent).
  __playHtmlAudio(__PING_WAV, 0.0001);
}

let __audioCtx = null;
let __audioUnlocked = false;
let __audioResumePromise = null;

function __getAudioCtx(){
  const Ctx = window.AudioContext || window.webkitAudioContext;
  if (!Ctx) return null;
  if (!__audioCtx) __audioCtx = new Ctx();
  return __audioCtx;
}

function __resumeAudio(){
  const ctx = __getAudioCtx();
  if (!ctx) return Promise.resolve(false);
  if (ctx.state === "running") return Promise.resolve(true);
  if (__audioResumePromise) return __audioResumePromise;
  __audioResumePromise = ctx.resume()
    .then(() => true)
    .catch(() => false)
    .finally(() => { __audioResumePromise = null; });
  return __audioResumePromise;
}

// iOS (Safari/PWA) often requires an explicit "unlock" on a user gesture
// before WebAudio will produce sound. We do this once, without changing UI.
function __unlockAudioOnce(){
  if (__audioUnlocked) return;
  const ctx = __getAudioCtx();
  if (!ctx) return;

  try {
    // Resume ASAP (must be called from user gesture). Do not await; just kick.
    if (ctx.state !== "running") ctx.resume().catch(() => {});

    // A near-silent oscillator tick tends to be more reliable than a 1-sample buffer on iOS.
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    g.gain.value = 0.0001;
    o.frequency.value = 440;
    o.connect(g);
    g.connect(ctx.destination);
    const t = ctx.currentTime + 0.02;
    o.start(t);
    o.stop(t + 0.02);
  } catch (e) {
    // ignore
  }

  __audioUnlocked = true;
}

function __beep(freq, dur, type="sine", vol=0.14){
  // Ensure audio is unlocked (iOS)
  __unlockAudioOnce();
  const ctx = __getAudioCtx();
  if (!ctx) return;

  try {
    // Build the graph synchronously inside the user gesture and schedule it slightly ahead.
    // This avoids relying on Promise callbacks, which iOS can treat as "not user-initiated".
    const o = ctx.createOscillator();
    const g = ctx.createGain();

    o.type = type;

    const t = ctx.currentTime + 0.02;

    o.frequency.setValueAtTime(freq, t);

    // Soft attack/release (avoid clicks)
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(vol, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

    o.connect(g);
    g.connect(ctx.destination);

    // Schedule start/stop even if the context is currently suspended.
    o.start(t);
    o.stop(t + dur + 0.03);

    // Kick resume (no await)
    if (ctx.state !== "running") ctx.resume().catch(() => {});
  } catch (e) {
    // ignore
  }
}

function sfxCorrect(){
  // iPhone/iPad: prefer HTMLAudio fallback (more reliable in Safari/PWA)
  if (__IS_IOS) {
    __primeHtmlAudioOnce();
    __playHtmlAudio(__PING_WAV, 1.0);
    return;
  }
  __beep(880, 0.08, "sine", 0.12);
  setTimeout(() => __beep(1320, 0.10, "sine", 0.12), 120);
}
function sfxWrong(){
  if (__IS_IOS) {
    __primeHtmlAudioOnce();
    __playHtmlAudio(__BUZZ_WAV, 1.0);
    return;
  }
  __beep(160, 0.22, "sawtooth", 0.18);
}
function vib(pattern){
  try { if (navigator.vibrate) navigator.vibrate(pattern); } catch(e) {}
}



function nowIso() {
  return new Date().toISOString();
}

function loadWords() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr : [];
  } catch {
    return [];
  }
}

function saveWords(words) {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(words));
    return true;
  } catch (e1) {
    try { setMsg("保存に失敗しました（容量不足の可能性）。先に単語保存で退避してください。", "ng"); } catch (_) {}
    return false;
  }
}











function buildBackupPayload() {
  return {
    app: "TANGO-CHO",
    version: APP_VERSION,
    exportedAt: nowIso(),
    words: loadWords(),
  };
}

function downloadJson(filename, obj) {
  const data = JSON.stringify(obj, null, 2);
  const blob = new Blob([data], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => { try { URL.revokeObjectURL(url); } catch (_) {} }, 1200);
}

function sanitizeImportedWords(arr) {
  if (!Array.isArray(arr)) return [];
  const out = [];
  for (const x of arr) {
    if (!x || typeof x !== "object") continue;
    const w = String(x.word || "").trim();
    const m = String(x.meaning || "").trim();
    if (!w) continue;
    out.push({
      id: x.id ? String(x.id) : (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random()),
      word: w,
      meaning: m,
      status: (x.status === "learned" || x.status === "unknown" || x.status === "default") ? x.status : "default",
      example: x.example ? String(x.example) : "",
      memo: x.memo ? String(x.memo) : "",
      tags: x.tags ? String(x.tags) : "",
      synonyms: x.synonyms ? String(x.synonyms) : "",
      source: x.source ? String(x.source) : "import",
      createdAt: x.createdAt ? String(x.createdAt) : nowIso(),
      updatedAt: x.updatedAt ? String(x.updatedAt) : undefined,
    });
  }










  return out;
}

// --- TTS: ensure English voice on iPhone/iOS ---
let __preferredEnVoice = null;
function __pickEnglishVoice(voices){
  if (!Array.isArray(voices) || voices.length === 0) return null;
  function score(v){
    const lang = String(v?.lang || "").toLowerCase();
    const name = String(v?.name || "").toLowerCase();
    let s = 0;
    if (lang === "en-us") s += 120;
    if (lang === "en-gb") s += 110;
    if (lang.startsWith("en-")) s += 100;
    if (lang.startsWith("en")) s += 80;
    if (v?.localService) s += 5;
    // Avoid Japanese voices that can be chosen as default on some iPhones
    if (name.includes("kyoko") || name.includes("otoya") || name.includes("japanese")) s -= 80;
    return s;
  }
  const sorted = [...voices].sort((a,b) => score(b) - score(a));
  const best = sorted[0];
  return score(best) > 0 ? best : null;
}
function __loadVoices(){
  try {
    const voices = window.speechSynthesis?.getVoices?.() || [];
    if (voices.length) {
      __preferredEnVoice = __pickEnglishVoice(voices);
    }
  } catch(e) {}
}

function speak(text) {
  if (!("speechSynthesis" in window)) {
    alert("この端末では音声読み上げが利用できません。");
    return;
  }

  // iOS loads voices asynchronously. Try to cache an English voice.
  __loadVoices();

  const u = new SpeechSynthesisUtterance(text);
  u.lang = "en-US";
  u.rate = 0.95;
  if (__preferredEnVoice) u.voice = __preferredEnVoice;
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(u);
}

function setMsg(text, kind) {
  const el = document.getElementById("msg");
  if (!el) return;
  el.className = "msg";
  el.textContent = text || "";
  if (kind === "ok") el.classList.add("ok");
  if (kind === "err") el.classList.add("err");
}

function setListMsg(text, kind) {
  const el = document.getElementById("listMsg");
  if (!el) return;
  el.className = "msg";
  el.textContent = text || "";
  if (kind === "ok") el.classList.add("ok");
  if (kind === "err") el.classList.add("err");
}


function normalizeHfBase(raw) {
  let v = (raw || "").trim();
  if (!v) return "";

  // Convert Hugging Face UI URL -> hf.space (best-effort)
  // https://huggingface.co/spaces/<owner>/<space>  ->  https://<owner>-<space>.hf.space
  const m = v.match(/^https?:\/\/huggingface\.co\/spaces\/([^\/]+)\/([^\/?#]+)/i);
  if (m) v = `https://${m[1]}-${m[2]}.hf.space`;

  try {
    const u = new URL(v);
    // Always use origin as API base; users sometimes paste /translate, /synonyms, /docs, etc.
    return u.origin.replace(/\/+$/, "");
  } catch (_) {
    return v.replace(/\/+$/, "");
  }
}

async function postJsonWithFallback(base, endpoints, payload, token) {
  const b = base.replace(/\/+$/, "");
  const headers = {
    "Content-Type": "application/json",
    ...(token ? { "X-App-Token": token } : {}),
  };

  let lastText = "";
  let lastStatus = 0;

  for (const ep of endpoints) {
    const url = `${b}${ep.startsWith("/") ? ep : `/${ep}`}`;
    let res;
    try {
      res = await fetch(url, { method: "POST", headers, body: JSON.stringify(payload) });
    } catch (e) {
      lastText = String(e?.message || e);
      lastStatus = 0;
      continue;
    }

    const text = await res.text().catch(() => "");
    lastText = text;
    lastStatus = res.status;

    // If endpoint is missing, try the next candidate
    if (res.status === 404) continue;

    // Parse JSON when possible
    let data = null;
    try { data = text ? JSON.parse(text) : null; } catch (_) {}

    if (!res.ok) {
      const detail = (data && (data.detail || data.message)) ? (data.detail || data.message) : text;
      // DeepL legacy auth deprecation hint
      if (res.status === 502 && /Legacy authentication method/i.test(detail || "")) {
        throw new Error("DeepL認証方式が更新されました。Spaces側をヘッダ認証（Authorization: DeepL-Auth-Key）に更新してください。");
      }
      throw new Error(`Spaces error: ${res.status} ${detail || ""}`.trim());
    }

    return data || {};
  }

  // All endpoints 404 (or network failed)
  if (lastStatus === 404) {
    throw new Error("Spaces APIが見つかりません（HF Spaces API Base は https://xxxxx.hf.space の“ルート”にしてください。末尾に /translate や /synonyms を付けないでください）。");
  }
  throw new Error(`Spaces error: ${lastStatus || ""} ${lastText || ""}`.trim());
}

function getHfBase() {
  // Fixed HF Spaces base (hidden from UI)
  const v = DEFAULT_HF_BASE;
  // Keep storage in sync for backward compatibility (safe no-op if blocked)
  try { localStorage.setItem(HF_BASE_KEY, v); } catch (_) {}
  return v;
}

function getAppToken() {
  let v = (localStorage.getItem(HF_TOKEN_KEY) || "").trim();

  if (!v) {
    const legacyKeys = ["tangoChoToken", "tangoChoAppTokenLegacy", "tangoChoApiToken"];
    for (const k of legacyKeys) {
      const t = (localStorage.getItem(k) || "").trim();
      if (t) {
        v = t;
        localStorage.setItem(HF_TOKEN_KEY, v);
        break;
      }
    }
  }

  if (!v) {
    const el = document.getElementById("appToken");
    if (el && el.value && el.value.trim()) v = el.value.trim();
  }
  return v;
}

async function translateToJaViaSpace(word) {
  const base = getHfBase();
  if (!base) throw new Error("HF Spaces API Base が未設定です（⚙️接続設定）。");
  const token = getAppToken();

  const data = await postJsonWithFallback(base, ["/translate", "/api/translate"], { text: word, target_lang: "JA" }, token);
  return data.translated || "";
}

async function fetchSynonymsViaSpace(word, max = 8) {
  const base = getHfBase();
  if (!base) throw new Error("HF Spaces API Base が未設定です（⚙️接続設定）。");
  const token = getAppToken();

  const data = await postJsonWithFallback(base, ["/synonyms", "/api/synonyms"], { text: word, max }, token);
  const arr = data?.synonyms || [];
  return Array.isArray(arr) ? arr : [];
}

async function getSynonymsSmart(word, max = 8) {
  return await fetchSynonymsViaSpace(word, max);
}


function setupTabs() {
  const btns = document.querySelectorAll(".tab-button");
  const secs = document.querySelectorAll(".section");
  btns.forEach((b) => {
    b.addEventListener("click", () => {
      const id = b.getAttribute("data-section");
      btns.forEach((x) => x.classList.remove("active"));
      secs.forEach((s) => s.classList.remove("active"));
      b.classList.add("active");
      document.getElementById(id)?.classList.add("active");
      // When entering list tab, rerender to reflect any changes
      if (id === "listSection") renderWordList();
    });
  });
}

function switchToAddTab() {
  const btn = document.querySelector('.tab-button[data-section="addSection"]');
  if (btn) btn.click();
}

// --- Incoming word (Android share target / iOS shortcut / URL param) ---
const SHARE_PAYLOAD_KEY = 'tangoChoSharePayload';

function extractFirstEnglishToken(s) {
  const str = String(s || '').trim();
  // Pick the first latin token (hyphen / apostrophe allowed)
  const m = str.match(/[A-Za-z][A-Za-z\-\u2019\']{0,60}/);
  if (!m) return '';
  return m[0].replace(/\u2019/g, "'").toLowerCase();
}

// Normalize user input or candidate into a clean English token (lowercase).
function normalizeWordInput(s){
  const t = extractFirstEnglishToken(String(s||''));
  if (!t) return '';
  // trim leading/trailing hyphen/apostrophe
  return t.replace(/^[-']+/, '').replace(/[-']+$/, '');
}
function isGoodRandomCandidate(token){
  const w = String(token||'').trim().toLowerCase();
  if (!w) return false;
  if (w.length < 2 || w.length > 18) return false;
  if (!/^[a-z][a-z\-']+$/.test(w)) return false;
  // avoid strange forms
  if (/--|''/.test(w)) return false;
  if (/[-']$/.test(w) || /^[-']/.test(w)) return false;
  return true;
}

// Track whether the current word came from Random button (used for graceful fallback).
let __lastWordFromRandom = false;

function consumeSharePayloadText() {
  try {
    const raw = localStorage.getItem(SHARE_PAYLOAD_KEY);
    if (!raw) return '';
    localStorage.removeItem(SHARE_PAYLOAD_KEY);
    const j = JSON.parse(raw);
    return String(j?.text || j?.title || j?.url || '').trim();
  } catch (_) {
    try { localStorage.removeItem(SHARE_PAYLOAD_KEY); } catch (e) {}
    return '';
  }
}

function getIncomingTextFromUrl() {
  try {
    const p = new URLSearchParams(location.search);
    const word = (p.get('word') || p.get('text') || p.get('q') || p.get('t') || '').trim();
    const title = (p.get('title') || '').trim();
    const url = (p.get('url') || '').trim();
    return (word || title || url) ? [word, title, url].filter(Boolean).join(' ') : '';
  } catch (_) {
    return '';
  }
}

function cleanupIncomingParams() {
  try {
    const u = new URL(location.href);
    ['word','text','q','t','title','url','from','v'].forEach((k) => u.searchParams.delete(k));
    history.replaceState(null, '', u.pathname + (u.search ? ('?' + u.searchParams.toString()) : '') + u.hash);
  } catch (_) {}
}

function applyIncomingWordToAddForm() {
  const urlText = getIncomingTextFromUrl();
  const shareText = consumeSharePayloadText();
  const raw = (urlText || shareText || '').trim();
  if (!raw) return;
  const token = extractFirstEnglishToken(raw);
  if (!token) { cleanupIncomingParams(); return; }

  const wordEl = document.getElementById('word');
  if (!wordEl) { cleanupIncomingParams(); return; }

  // Move user to Add tab and prefill the word field (no UI changes)
  switchToAddTab();
  wordEl.value = token;
  try { wordEl.dispatchEvent(new Event('input', { bubbles: true })); } catch (_) {}
  setTimeout(() => {
    try {
      wordEl.focus();
      const n = wordEl.value.length;
      wordEl.setSelectionRange(n, n);
    } catch (_) {}
  }, 50);

  cleanupIncomingParams();
}


function setupSettings() {
  const hfBase = document.getElementById("hfBase");
  const saveHfBaseBtn = document.getElementById("saveHfBaseBtn");
  const appToken = document.getElementById("appToken");
  const saveAppTokenBtn = document.getElementById("saveAppTokenBtn");
  const exportJsonBtn = document.getElementById("exportJsonBtn");
  const importJsonBtn = document.getElementById("importJsonBtn");
  const importJsonInput = document.getElementById("importJsonInput");

  // restore current settings
  try {
    const b = normalizeHfBase(localStorage.getItem(HF_BASE_KEY) || "");
    if (hfBase) hfBase.value = b;
    if (appToken) appToken.value = (localStorage.getItem(HF_TOKEN_KEY) || "").trim();
  } catch (_) {}

  const connStatus = document.getElementById("connStatus");

  hfBase.value = getHfBase();
  appToken.value = getAppToken();

  function updateConnBadge() {
  if (!connStatus) return;
  const kw = (appToken?.value || localStorage.getItem(HF_TOKEN_KEY) || '').trim();
  connStatus.textContent = kw ? '✅ キーワード設定済み' : '⚠️ キーワード未設定';
}
  updateConnBadge();

  saveHfBaseBtn?.addEventListener("click", () => {
    // no-op (HF base is fixed)
    setMsg("接続先はアプリ内で固定されています。", "ok");
  });

saveAppTokenBtn?.addEventListener("click", () => {
    localStorage.setItem(HF_TOKEN_KEY, appToken.value.trim());
    setMsg("キーワードを保存しました。", "ok");
  });


  

  exportJsonBtn?.addEventListener("click", () => {
    try {
      const ymd = new Date().toISOString().slice(0,10).replaceAll("-", "");
      downloadJson(`tangocho-backup-${ymd}.json`, buildBackupPayload());
      setMsg("単語を保存しました。", "ok");
    } catch (e) {
      setMsg("単語の保存に失敗しました。", "ng");
    }
  });

  importJsonBtn?.addEventListener("click", () => {
    try { importJsonInput?.click(); } catch (_) {}
  });
importJsonInput?.addEventListener("change", async () => {
    const file = importJsonInput.files && importJsonInput.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const obj = JSON.parse(text);
      const arr = Array.isArray(obj) ? obj : (Array.isArray(obj.words) ? obj.words : null);
      if (!arr) throw new Error("invalid");
      const imported = sanitizeImportedWords(arr);
      if (imported.length === 0) throw new Error("empty");

      const ok = confirm(`単語を復元します。現在の単語帳（${loadWords().length}件）を上書きして、${imported.length}件に置き換えます。よろしいですか？`);
      if (!ok) return;

      saveWords(imported);
      setMsg(`単語を復元しました（${imported.length}件）。`, "ok");
      try { renderWordList(); } catch (_) {}
    } catch (e) {
      setMsg("単語の復元に失敗しました。ファイル形式を確認してください。", "ng");
    } finally {
      try { importJsonInput.value = ""; } catch (_) {}
    }
  });
// Auto-save (user may forget pressing "保存")
  hfBase?.addEventListener("blur", () => {
    try { hfBase.value = DEFAULT_HF_BASE; } catch (_) {}
    try { localStorage.setItem(HF_BASE_KEY, DEFAULT_HF_BASE); } catch (_) {}
    updateConnBadge();
  });

hfBase?.addEventListener("change", () => {
    try { hfBase.value = DEFAULT_HF_BASE; } catch (_) {}
    try { localStorage.setItem(HF_BASE_KEY, DEFAULT_HF_BASE); } catch (_) {}
    updateConnBadge();
  });

appToken.addEventListener("blur", () => {
    localStorage.setItem(HF_TOKEN_KEY, appToken.value.trim());
  });
  appToken.addEventListener("change", () => {
    localStorage.setItem(HF_TOKEN_KEY, appToken.value.trim());
  });
}

function setupAddForm() {
  const wordEl = document.getElementById("word");

  if (wordEl) {
    wordEl.addEventListener('input', () => { __lastWordFromRandom = false; });
  }
  const meaningEl = document.getElementById("meaning");
  const statusEl = document.getElementById("status");
  const exampleEl = document.getElementById("example");
  const memoEl = document.getElementById("memo");
  const tagsEl = document.getElementById("tags");
  const synonymsEl = document.getElementById("synonyms");
  const synFetchBtn = document.getElementById("synFetchBtn");
  const translateBtn = document.getElementById("translateBtn");
  const randomBtn = document.getElementById("randomBtn");
  const saveBtn = document.getElementById("saveBtn");
  const clearBtn = document.getElementById("clearBtn");
  const ttsBtn = document.getElementById("ttsBtn");
  const statePill = document.getElementById("translateState");
  const editBanner = document.getElementById("editBanner");
  const editSub = document.getElementById("editSub");
  const cancelEditBtn = document.getElementById("cancelEditBtn");

  function setState(text) {
    if (!statePill) return;
    statePill.textContent = text;
  }

  function clearForm(afterSave=false) {
    wordEl.value = "";
    meaningEl.value = "";
    statusEl.value = "default";
    exampleEl.value = "";
    memoEl.value = "";
    tagsEl.value = "";
    if (synonymsEl) synonymsEl.value = "";
    setState("未翻訳");
    if (!afterSave) setMsg("", "");
  }

  function enterEditMode(item) {
    editId = item.id;
    wordEl.value = item.word || "";
    meaningEl.value = item.meaning || "";
    statusEl.value = item.status || "default";
    exampleEl.value = item.example || "";
    memoEl.value = item.memo || "";
    tagsEl.value = item.tags || "";
    if (synonymsEl) synonymsEl.value = item.synonyms || "";

    if (editBanner) editBanner.style.display = "flex";
    if (editSub) editSub.textContent = `${(item.word || "").trim()} を編集中`;

    saveBtn.textContent = "更新";
    setState("編集");
    setMsg("編集モードに入りました。内容を修正して「更新」を押してください。", "ok");

    switchToAddTab();
    wordEl.focus();
  }

  function exitEditMode(showMsg = false) {
    editId = null;
    if (editBanner) editBanner.style.display = "none";
    saveBtn.textContent = "単語帳に保存";
    clearForm(false);
    if (showMsg) setMsg("編集を終了しました。", "ok");
  }

  // expose for list tab
  window.startEdit = (id) => {
    const all = loadWords();
    const item = all.find((x) => x.id === id);
    if (!item) return;
    enterEditMode(item);
  };

  cancelEditBtn?.addEventListener("click", () => exitEditMode(true));



  ttsBtn.addEventListener("click", () => {
    const w = wordEl.value.trim();
    if (w) speak(w);
  });

  clearBtn.addEventListener("click", () => {
    if (editId) return exitEditMode(true);
    clearForm(false);
  });


  function pickRandomWord() {
    const toeic = window.TOEIC_POOL;
    const full = window.VOCAB_POOL;

    // TOEIC-biased sampling (no extra UI): 90% TOEIC pool, 10% general pool.
    const TOEIC_BIAS = 0.90;
    const useToeic = Array.isArray(toeic) && toeic.length > 0 && (Math.random() < TOEIC_BIAS);

    const pool = useToeic ? toeic : full;
    if (!Array.isArray(pool) || pool.length === 0) return null;

    const cap = getDifficultyCap();
    const hardLimit = 5000; // keep random practical (avoid very rare words)
    const subset = pool.slice(0, Math.min(cap, hardLimit, pool.length));

    const registered = new Set(loadWords().map(w => String(w.word || "").toLowerCase()));

    const RAND_COUNTER_KEY = "tangoChoRandCounter";
    const RAND_HIST_KEY = "tangoChoRandHist";
    let counter = 0;
    try {
      counter = parseInt(localStorage.getItem(RAND_COUNTER_KEY) || "0", 10);
      counter = Number.isFinite(counter) ? counter + 1 : 1;
      localStorage.setItem(RAND_COUNTER_KEY, String(counter));
    } catch (_) { counter = Date.now(); }

    let hist = [];
    try {
      hist = JSON.parse(localStorage.getItem(RAND_HIST_KEY) || "[]");
      if (!Array.isArray(hist)) hist = [];
    } catch (_) { hist = []; }
    hist = hist.slice(-40).map(x => String(x || "").toLowerCase());
    const histSet = new Set(hist);

    const rnd = __mulberry32(__hash32(`rand:${__todayKey()}:${counter}:${cap}:${registered.size}`));
    let candidate = null;

    for (let guard = 0; guard < 600; guard++) {
      const w = subset[Math.floor(rnd() * subset.length)];
      if (!w) continue;
      const lw = normalizeWordInput(w);
      if (!isGoodRandomCandidate(lw)) continue;
      if (registered.has(lw)) continue;
      if (histSet.has(lw)) continue;
      candidate = lw;
      break;
    }
    if (!candidate) {
      // fallback: allow repeats if exhausted
      candidate = normalizeWordInput(subset[Math.floor(rnd() * subset.length)] || "") || null;
    }
    if (!candidate) return null;

    try {
      hist.push(candidate);
      localStorage.setItem(RAND_HIST_KEY, JSON.stringify(hist.slice(-40)));
    } catch (_) {}

    return candidate;
  }

  if (randomBtn) {
    randomBtn.addEventListener("click", () => {
      if (editId) return setMsg("編集中はランダムを使えません（編集を解除してください）。", "err");

      // reset UI (do NOT auto-fetch synonyms)
      try { if (synonymsEl) synonymsEl.value = ""; } catch (_) {}
      try { meaningEl.value = ""; } catch (_) {}
      setState("未翻訳");
      setMsg("", "");

      const picked = pickRandomWord();
      if (!picked) return setMsg("ランダム候補が見つかりません。", "err");

      wordEl.value = picked;
      __lastWordFromRandom = true;
      wordEl.focus();
    });
  }


  translateBtn.addEventListener("click", async () => {
    const raw = wordEl.value;
    const w = normalizeWordInput(raw);
    if (!w) return setMsg("英単語（アルファベット）を入力してください。", "err");

    // If user pasted a sentence, keep only the first English token (quietly).
    if (String(raw||"").trim().toLowerCase() !== w) {
      wordEl.value = w;
    }

    setMsg("翻訳中...", "");
    setState("翻訳中");
    try {
      const ja = await translateToJaViaSpace(w);

      const jaTrim = String(ja||"").trim();
      // If translation is empty or unchanged, treat as not suitable for learning.
      if (!jaTrim || jaTrim.toLowerCase() === w.toLowerCase()) {
        meaningEl.value = "";
        setState("未翻訳");
        if (__lastWordFromRandom) {
          __lastWordFromRandom = false;
          // Show another candidate (no extra buttons, just recover gracefully)
          const picked = pickRandomWord();
          if (picked) {
            wordEl.value = picked;
            setMsg("この単語は翻訳できない可能性があるため、別の候補に切り替えました。", "ok");
            wordEl.focus();
            return;
          }
        }
        return setMsg("翻訳できない単語の可能性があります。別の単語を試してください。", "err");
      }

      meaningEl.value = jaTrim;
      setMsg("翻訳しました（編集できます）。", "ok");
      setState("翻訳済み");
      __lastWordFromRandom = false;
    } catch (e) {
      setMsg(String(e.message || e), "err");
      setState("失敗");
    }
  });

  async function fillSynonymsIfEmpty(word) {
    if (!synonymsEl) return;
    if (synonymsEl.value.trim()) return; // don't overwrite user input
    try {
      const syns = await getSynonymsSmart(word, 8);
      if (syns.length) {
        synonymsEl.value = syns.slice(0, 8).join(", ");
        setMsg(`類義語を自動取得しました（${Math.min(8, syns.length)}件）。`, "ok");
      }
    } catch (e) {
      // silent, avoid annoying
    }
  }

  if (synFetchBtn) {
    synFetchBtn.addEventListener("click", async () => {
      const raw = wordEl.value;
      const w = normalizeWordInput(raw);
      if (!w) return setMsg("英単語（アルファベット）を入力してください。", "err");
      if (String(raw||"").trim().toLowerCase() !== w) wordEl.value = w;
      try {
        const syns = await getSynonymsSmart(w, 8);
        synonymsEl.value = syns.slice(0, 8).join(", ");
        if (syns.length) {
          setMsg(`類義語を取得しました（${Math.min(8, syns.length)}件）。`, "ok");
        } else {
          setMsg("類義語が見つかりませんでした。別の単語で試すか「ランダム」を押してください。", "ok");
        }
      } catch (e) {

        setMsg(String(e && e.message ? e.message : "類義語の取得に失敗しました。"), "err");
      }
    });
  }


  saveBtn.addEventListener("click", async () => {
    const w = wordEl.value.trim();
    const m = meaningEl.value.trim();
    if (!w) return setMsg("英単語が空です。", "err");
    if (!m) return setMsg("日本語訳が空です（翻訳 or 手入力してください）。", "err");

    const words = loadWords();
    const now = nowIso();

    // ===== Edit mode =====
    let baseId = `${now}-${Math.random().toString(36).slice(2, 8)}`;
    if (editId) {
      const idx = words.findIndex((x) => x.id === editId);
      if (idx >= 0) {
        const prev = words[idx];
        baseId = prev.id;
        words[idx] = {
          ...prev,
          word: w,
          meaning: m,
          status: statusEl.value || "default",
          example: exampleEl.value.trim(),
          memo: memoEl.value.trim(),
          tags: tagsEl.value.trim(),
          synonyms: synonymsEl ? synonymsEl.value.trim() : (prev.synonyms || ""),
          updatedAt: now,
        };
      } else {
        // If the item disappeared, fall back to adding as new.
        editId = null;
      }
    }

    // ===== Add new if not editing =====
    if (!editId) {
      words.push({
        id: baseId,
        word: w,
        meaning: m,
        status: statusEl.value || "default",
        example: exampleEl.value.trim(),
        memo: memoEl.value.trim(),
        tags: tagsEl.value.trim(),
        synonyms: synonymsEl ? synonymsEl.value.trim() : "",
        source: "manual",
        createdAt: now,
      });
    }

    // ===== Auto-add synonym cards (comma-separated) =====
    const synRaw = (synonymsEl ? synonymsEl.value : "").trim();
    const synTokens = synRaw
      ? synRaw.split(/[,、\n\r]+/).map((s) => s.trim()).filter(Boolean)
      : [];

    const seen = new Set();
    const baseLower = w.toLowerCase();
    const existingWordLower = new Set(words.map((x) => String(x.word || "").toLowerCase()));
    let synAdded = 0;
    const synFailed = [];

    for (const t of synTokens) {
      const tl = t.toLowerCase();
      if (!t || tl === baseLower) continue;
      if (seen.has(tl)) continue;
      seen.add(tl);

      // already exists -> skip (do not overwrite)
      if (existingWordLower.has(tl)) continue;

      // re-translate each synonym before carding (avoid "meaning" reuse)
      let meaningSyn = "";
      try {
        meaningSyn = await translateToJaViaSpace(t);
      } catch (e) {
        synFailed.push(t);
        continue;
      }
      if (!meaningSyn) {
        synFailed.push(t);
        continue;
      }

      words.push({
        id: `${baseId}-syn-${Math.random().toString(36).slice(2, 8)}`,
        word: t,
        meaning: meaningSyn,
        status: statusEl.value || "default",
        example: "",
        memo: `同義語（${w}）`,
        tags: tagsEl.value.trim(),
        synonyms: "",
        source: "synonym",
        createdAt: nowIso(),
      });
      existingWordLower.add(tl);
      synAdded += 1;
    }

    const synFailNote = synFailed.length
      ? `（類似語の再翻訳失敗: ${synFailed.slice(0, 3).join(", ")}${synFailed.length > 3 ? " 他" + (synFailed.length - 3) : ""}）`
      : "";


    saveWords(words);

    if (editId) {
      exitEditMode(false);
      setMsg(`更新しました（入力をクリアしました）。${synAdded ? ` 類似語カード +${synAdded}` : ""}${synFailNote}`.trim());
    } else {
      clearForm(true);
      setMsg(`保存しました（入力をクリアしました）。${synAdded ? ` 類似語カード +${synAdded}` : ""}${synFailNote}`.trim(), "ok");
    }

    renderWordList();
    wordEl.focus();
  });
}


// --- Deterministic helpers (seeded shuffle etc.) ---
function __hash32(str){
  // xmur3 (simple 32-bit hash)
  let h = 1779033703 ^ (str ? str.length : 0);
  for (let i = 0; i < (str ? str.length : 0); i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return (h >>> 0);
}
function __mulberry32(a){
  return function(){
    let t = (a += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function __todayKey(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const day = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${day}`;
}
function __shuffleInPlace(arr, seedStr){
  const rnd = __mulberry32(__hash32(String(seedStr||"seed")));
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(rnd() * (i + 1));
    const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
  }
  return arr;
}

// --- Adaptive difficulty cap (no extra UI) ---
function getDifficultyCap(){
  const max = (window.VOCAB_POOL && Array.isArray(window.VOCAB_POOL)) ? window.VOCAB_POOL.length : 12000;
  const minCap = 800;
  let v = parseInt(localStorage.getItem(DIFF_CAP_KEY) || "1600", 10);
  if (!Number.isFinite(v)) v = 1600;
  v = Math.max(minCap, Math.min(max, v));
  return v;
}
function setDifficultyCap(v){
  const max = (window.VOCAB_POOL && Array.isArray(window.VOCAB_POOL)) ? window.VOCAB_POOL.length : 12000;
  const minCap = 800;
  let x = parseInt(String(v||0), 10);
  if (!Number.isFinite(x)) x = 1200;
  x = Math.max(minCap, Math.min(max, x));
  localStorage.setItem(DIFF_CAP_KEY, String(x));
  return x;
}
function getStudyHist(){
  try{
    const raw = localStorage.getItem(STUDY_HIST_KEY);
    if (!raw) return [];
    const arr = JSON.parse(raw);
    return Array.isArray(arr) ? arr.slice(-80) : [];
  }catch(_){ return []; }
}
function setStudyHist(arr){
  try{
    const a = Array.isArray(arr) ? arr.slice(-80) : [];
    localStorage.setItem(STUDY_HIST_KEY, JSON.stringify(a));
  }catch(_){}
}
function recordStudyResult(isCorrect){
  const hist = getStudyHist();
  hist.push(isCorrect ? 1 : 0);
  setStudyHist(hist);

  // Adjust only when we have enough signal
  const n = hist.length;
  const windowN = Math.min(50, n);
  const slice = hist.slice(-windowN);
  const correct = slice.reduce((s,x)=>s+(x?1:0),0);
  const rate = correct / windowN;

  let cap = getDifficultyCap();
  if (windowN >= 20){
    if (rate >= 0.85) cap += 120;
    else if (rate <= 0.55) cap -= 120;
    // else: keep
    setDifficultyCap(cap);
  }
}
function capToFortuneLevel(cap){
  // Simple thresholds; tuned to feel natural.
  if (cap < 1200) return "jhs";
  if (cap < 2200) return "hs";
  return "adult";
}


function renderWordList() {
  const listEl = document.getElementById("wordList");
  const countEl = document.getElementById("wordCount");
  const filter = (localStorage.getItem(FILTER_KEY) || "all").trim();
  const tagFilter = (localStorage.getItem(TAG_FILTER_KEY) || "all").trim();
  const sortOrder = (localStorage.getItem(SORT_KEY) || "time").trim();
  const all = loadWords();

  // Tag filter options depend on current words
  try { syncTagFilterOptions(all); } catch (_) {}

  if (countEl) countEl.textContent = String(all.length);
  if (!listEl) return;

  let words = [...all];
  if (sortOrder === "alpha") {
    words.sort((a, b) => String(a.word || "").toLowerCase().localeCompare(String(b.word || "").toLowerCase()));
  } else if (sortOrder === "tag") {
    words.sort((a, b) => {
      const at = (parseTags(a.tags)[0] || "");
      const bt = (parseTags(b.tags)[0] || "");
      const c = at.toLowerCase().localeCompare(bt.toLowerCase());
      if (c !== 0) return c;
      return String(a.word || "").toLowerCase().localeCompare(String(b.word || "").toLowerCase());
    });
  } else {
    // time (default): newest first
    words.sort((a, b) => (b.createdAt || "").localeCompare(a.createdAt || ""));
  }
  if (filter !== "all") words = words.filter((w) => (w.status || "default") === filter);
  if (tagFilter !== "all") {
    const tf = String(tagFilter || "").toLowerCase();
    words = words.filter((w) => parseTags(w.tags).some((t) => t.toLowerCase() === tf));
  }
listEl.innerHTML = "";

  if (words.length === 0) {
    listEl.innerHTML = `<p style="font-size:0.85rem;color:#888;">該当する単語がありません。</p>`;
    return;
  }

  for (const w of words) {
    const item = document.createElement("div");
    item.className = "word-item";

    const top = document.createElement("div");
    top.className = "word-top";

    const left = document.createElement("div");
    left.className = "word-main";
    left.textContent = w.word || "(unknown)";

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.gap = "6px";
    right.style.alignItems = "center";

    const tts = document.createElement("button");
    tts.className = "tts-btn";
    tts.textContent = "🔊";
    tts.title = "発音";
    tts.addEventListener("click", () => w.word && speak(w.word));

    const status = document.createElement("select");
    status.className = "select small";
    status.innerHTML = `
      <option value="forgot">覚えてない</option>
      <option value="default">デフォルト</option>
      <option value="learned">覚えた</option>
    `;
    status.value = w.status || "default";
    status.addEventListener("change", () => {
      const allWords = loadWords();
      const idx = allWords.findIndex((x) => x.id === w.id);
      if (idx >= 0) {
        allWords[idx].status = status.value;
        saveWords(allWords);
        renderWordList(); // filter might hide/show
      }
    });

    right.appendChild(tts);
    right.appendChild(status);

    top.appendChild(left);
    top.appendChild(right);

    const meaning = document.createElement("div");
    meaning.className = "word-meaning";
    meaning.textContent = w.meaning || "";

    const syn = (w.synonyms || "").trim();
    let synEl = null;
    if (syn) {
      synEl = document.createElement("div");
      synEl.className = "word-synonyms";
      synEl.textContent = `類似語: ${syn}`;
    }

    const meta = document.createElement("div");
    meta.className = "word-meta";
    const created = w.createdAt ? new Date(w.createdAt).toLocaleString() : "";
    const tags = w.tags ? ` / タグ: ${w.tags}` : "";
    const st = ` / ${STATUS_LABEL[w.status || "default"]}`;
    meta.textContent = `登録: ${created}${tags}${st}`;

    const actions = document.createElement("div");
    actions.className = "word-actions";

    const edit = document.createElement("button");
    edit.className = "ghost-btn small";
    edit.textContent = "編集";
    edit.addEventListener("click", () => {
      if (typeof window.startEdit === "function") window.startEdit(w.id);
    });

    const del = document.createElement("button");
    del.className = "delete-btn";
    del.textContent = "削除";
    del.addEventListener("click", () => {
      if (!confirm(`「${w.word}」を削除しますか？`)) return;
      const next = loadWords().filter((x) => x.id !== w.id);
      saveWords(next);
      renderWordList();
    });

    actions.appendChild(edit);

    actions.appendChild(del);

    item.appendChild(top);
    item.appendChild(meaning);
    if (synEl) item.appendChild(synEl);

    if (w.example) {
      const ex = document.createElement("div");
      ex.className = "word-meta";
      ex.textContent = `例: ${w.example}`;
      item.appendChild(ex);
    }
    if (w.memo) {
      const mm = document.createElement("div");
      mm.className = "word-meta";
      mm.textContent = `メモ: ${w.memo}`;
      item.appendChild(mm);
    }

    item.appendChild(meta);
    item.appendChild(actions);
    listEl.appendChild(item);
  }
}

function setupFilter() {
  const sel = document.getElementById("statusFilter");
  if (!sel) return;
  sel.value = (localStorage.getItem(FILTER_KEY) || "all").trim();
  sel.addEventListener("change", () => {
    localStorage.setItem(FILTER_KEY, sel.value);
    renderWordList();
  });
}

function setupSort() {
  const sel = document.getElementById("sortOrder");
  if (!sel) return;
  sel.value = (localStorage.getItem(SORT_KEY) || "time").trim();
  sel.addEventListener("change", () => {
    localStorage.setItem(SORT_KEY, sel.value);
    renderWordList();
  });
}

function parseTags(raw) {
  const s = String(raw || "")
    .replace(/、/g, ",")
    .replace(/，/g, ",")
    .trim();
  if (!s) return [];
  return s
    .split(",")
    .map((x) => x.trim())
    .filter((x) => x.length > 0);
}

function collectTagOptions(words) {
  const map = new Map(); // norm -> display
  for (const w of words || []) {
    const tags = parseTags(w.tags);
    for (const t of tags) {
      const norm = t.toLowerCase();
      if (!map.has(norm)) map.set(norm, t);
    }
  }
  const arr = Array.from(map.entries()).map(([norm, display]) => ({ norm, display }));
  arr.sort((a, b) => a.display.toLowerCase().localeCompare(b.display.toLowerCase()));
  return arr;
}

function syncTagFilterOptions(allWords) {
  const sel = document.getElementById("tagFilter");
  if (!sel) return;
  const opts = collectTagOptions(allWords);
  const keep = (localStorage.getItem(TAG_FILTER_KEY) || sel.value || "all").trim() || "all";
  sel.innerHTML = `<option value="all">タグ: 全て</option>` + opts.map(o => `<option value="${o.norm}">${o.display}</option>`).join("");
  if (sel.querySelector(`option[value="${keep}"]`)) {
    sel.value = keep;
  } else {
    sel.value = "all";
    localStorage.setItem(TAG_FILTER_KEY, "all");
  }
}

function setupTagFilter() {
  const sel = document.getElementById("tagFilter");
  if (!sel) return;
  sel.value = (localStorage.getItem(TAG_FILTER_KEY) || "all").trim();
  sel.addEventListener("change", () => {
    localStorage.setItem(TAG_FILTER_KEY, sel.value);
    renderWordList();
  });
}



function setupExport() {
  const btn = document.getElementById("exportBtn");
  if (!btn) return;
  btn.addEventListener("click", () => {
    const words = loadWords();
    const blob = new Blob([JSON.stringify(words, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const now = new Date();
    const ts = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,"0")}-${String(now.getDate()).padStart(2,"0")}`;
    a.href = url;
    a.download = `tango-cho-backup-${ts}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
}

// --------------------
// Quiz (4-choice)
// --------------------
let quizState = {
  active: false,
  current: null,
  answered: false,
  correct: 0,
  total: 0,
};

// --- Quiz deck (no repeats until one full cycle) ---
// Purpose: once a word is asked, it will not appear again until the pool is fully cycled.
// For pool=all, we bias the early order: forgot > default > learned.
let quizDeckState = {
  key: "",
  order: [],
  idx: 0,
};

// Ratio used only when pool="all" (bigger = earlier/more frequent in the early phase)
const QUIZ_ALL_RATIO = { forgot: 5, default: 3, learned: 1 };

function _buildQuizDeckOrder(poolWords, pool) {
  const ids = poolWords.map(w => w.id);
  if (pool !== "all") {
    return choiceShuffle(ids);
  }

  const groups = { forgot: [], default: [], learned: [] };
  for (const w of poolWords) {
    const st = (w && w.status) ? String(w.status) : "default";
    if (st === "forgot" || st === "default" || st === "learned") groups[st].push(w.id);
    else groups.default.push(w.id);
  }

  groups.forgot = choiceShuffle(groups.forgot);
  groups.default = choiceShuffle(groups.default);
  groups.learned = choiceShuffle(groups.learned);

  const order = [];
  const steps = [
    ["forgot", QUIZ_ALL_RATIO.forgot],
    ["default", QUIZ_ALL_RATIO.default],
    ["learned", QUIZ_ALL_RATIO.learned],
  ];

  // Interleave by ratio while any items remain
  while (groups.forgot.length || groups.default.length || groups.learned.length) {
    for (const [k, n] of steps) {
      for (let i = 0; i < n; i++) {
        if (groups[k].length) order.push(groups[k].pop());
      }
    }
  }

  return order;
}

function _ensureQuizDeck(mode, pool, poolWords) {
  const key = `${mode}|${pool}`;
  const needsNew = (quizDeckState.key !== key) || (quizDeckState.order.length === 0) || (quizDeckState.idx >= quizDeckState.order.length);
  if (!needsNew) return;
  quizDeckState.key = key;
  quizDeckState.order = _buildQuizDeckOrder(poolWords, pool);
  quizDeckState.idx = 0;
}

function _pickNextTargetFromDeck(mode, pool, poolWords) {
  _ensureQuizDeck(mode, pool, poolWords);
  const idToWord = new Map(poolWords.map(w => [w.id, w]));
  const total = quizDeckState.order.length;
  for (let i = 0; i < total; i++) {
    const id = quizDeckState.order[quizDeckState.idx % total];
    quizDeckState.idx += 1;
    const w = idToWord.get(id);
    if (w) return w;
  }
  // Fallback (should be rare)
  return poolWords[Math.floor(Math.random() * poolWords.length)];
}


function choiceShuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function weightedPick(items, weightFn) {
  const weights = items.map(weightFn);
  const sum = weights.reduce((s, w) => s + w, 0);
  if (sum <= 0) return items[Math.floor(Math.random() * items.length)];
  let r = Math.random() * sum;
  for (let i = 0; i < items.length; i++) {
    r -= weights[i];
    if (r <= 0) return items[i];
  }
  return items[items.length - 1];
}

function getPoolWords(pool) {
  const all = loadWords();
  if (pool === "all") return all;
  return all.filter(w => (w.status || "default") === pool);
}

function statusWeight(st) {
  if (st === "forgot") return 3;
  if (st === "default") return 2;
  if (st === "learned") return 1;
  return 2;
}

function buildQuestion(mode, pool) {
  const poolWords = getPoolWords(pool);
  if (poolWords.length < 4) return { error: "4択クイズには、同じ出題カテゴリ内に単語が最低4つ必要です。" };

  // For 日→英 (ja2en): show Japanese meaning under each English choice.
  // Build a quick lookup table: { [word]: meaning }
  const wordToMeaning = {};
  for (const w of poolWords) {
    const k = (w && w.word) ? String(w.word) : "";
    if (!k) continue;
    if (wordToMeaning[k] == null) wordToMeaning[k] = String(w.meaning || "");
  }

  const target = _pickNextTargetFromDeck(mode, pool, poolWords);
  const prompt = mode === "en2ja" ? target.word : (target.meaning || "");
  const correct = mode === "en2ja" ? (target.meaning || "") : target.word;

  // distractors
  const others = poolWords.filter(w => w.id !== target.id);
  const seen = new Set([correct]);
  const distract = [];
  const keyOf = (w) => mode === "en2ja" ? (w.meaning || "") : (w.word || "");
  const shuffled = choiceShuffle(others);

  for (const w of shuffled) {
    const k = keyOf(w);
    if (!k) continue;
    if (seen.has(k)) continue;
    seen.add(k);
    distract.push(k);
    if (distract.length >= 3) break;
  }

  if (distract.length < 3) {
    return { error: "4択の選択肢を作れませんでした（訳/単語の重複が多い可能性）。別カテゴリを選ぶか、単語数を増やしてください。" };
  }

  const choices = choiceShuffle([correct, ...distract]);

  return { target, mode, prompt, correct, choices, wordToMeaning };
}

function renderQuiz() {
  const area = document.getElementById("quizArea");
  const score = document.getElementById("scorePill");
  const nextBtn = document.getElementById("nextQuizBtn");
  if (!area || !score || !nextBtn) return;

  score.textContent = `${quizState.correct} / ${quizState.total}`;

  if (!quizState.active || !quizState.current) {
    area.innerHTML = `<p class="note">「出題」を押すと始まります。※ 4択クイズは、単語が最低4つ必要です。</p>`;
    nextBtn.disabled = true;
    nextBtn.style.display = "none";
    return;
  }

  const q = quizState.current;
  if (q.error) {
    area.innerHTML = `<p class="note" style="color:#ff4f4f;">${q.error}</p>`;
    nextBtn.disabled = true;
    nextBtn.style.display = "none";
    return;
  }

  const modeLabel = q.mode === "en2ja" ? "英 → 日" : "日 → 英";
  const promptLabel = q.mode === "en2ja" ? "この英単語の意味は？" : "この日本語に対応する英単語は？";

  area.innerHTML = `
    <p class="quiz-mini">${modeLabel}</p>
    <p class="quiz-q">${promptLabel}<br><span style="font-size:1.25rem;">${escapeHtml(q.prompt)}</span></p>
    <div id="quizResult" class="quiz-result" aria-live="polite"></div>
    <div id="quizReveal" class="quiz-reveal" aria-live="polite"></div>
    <div class="quiz-choices" id="choices"></div>
    <div class="quiz-foot" id="quizFoot"></div>
    <div id="quizNextWrap" class="quiz-next-wrap"></div>
  `;

  const choicesEl = document.getElementById("choices");
  const footEl = document.getElementById("quizFoot");
  const resultEl = document.getElementById("quizResult");
  const revealEl = document.getElementById("quizReveal");
  if (resultEl) { resultEl.className = "quiz-result"; resultEl.textContent = ""; }
  if (revealEl) revealEl.innerHTML = "";

  choicesEl.innerHTML = "";

  q.choices.forEach((c) => {
    const b = document.createElement("button");
    b.className = "choice-btn";
    // keep the raw choice for marking (don't rely on textContent because we may add subtext)
    b.dataset.choice = c;
    if (q.mode === "ja2en") {
      // 日→英クイズ：日本語訳は「解答後のみ」表示する
      const ja = (q.wordToMeaning && q.wordToMeaning[c]) ? q.wordToMeaning[c] : "";
      b.innerHTML = `
        <div class="choice-main">${escapeHtml(c)}</div>
        <div class="choice-sub" data-ja="${escapeHtml(ja)}"></div>
      `;
    } else {
      b.textContent = c;
    }
    b.disabled = quizState.answered;
    b.addEventListener("click", () => onAnswer(c));
    choicesEl.appendChild(b);
  });

  footEl.innerHTML = `<span class="quiz-mini">出題元カテゴリ: ${STATUS_LABEL[q.target.status || "default"]}</span>`;
  // Move the existing next button to the bottom of the quiz area (full width)
  const nextWrap = document.getElementById("quizNextWrap");
  if (nextWrap && nextBtn.parentElement !== nextWrap) {
    nextWrap.appendChild(nextBtn);
  }
  nextBtn.classList.add("full-width", "quiz-next-btn");
  nextBtn.style.display = "";
  nextBtn.disabled = !quizState.answered;
}

function escapeHtml(s) {
  return String(s || "").replace(/[&<>"']/g, (m) => ({
    "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;"
  }[m]));
}

function onAnswer(selected) {
  if (!quizState.current || quizState.answered) return;
  quizState.answered = true;
  quizState.total += 1;

  const q = quizState.current;
  const isCorrect = selected === q.correct;
  if (isCorrect) quizState.correct += 1;
  try{ recordStudyResult(isCorrect); }catch(_){}

  // SFX + big mark
  const resultEl = document.getElementById("quizResult");
  if (isCorrect) { sfxCorrect(); vib(40); }
  else { sfxWrong(); vib([60,40,120]); }
  if (resultEl) {
    resultEl.classList.add(isCorrect ? "correct" : "wrong");
    if (isCorrect) {
      resultEl.innerHTML = `<span class="mark">○</span><span>正解</span>`;
    } else {
      // Avoid duplicate "answer" display; the correct answer is revealed below.
      resultEl.innerHTML = `<span class="mark">✕</span><span>不正解</span>`;
    }
  }

  // After answering: reveal the answer (minimal, without duplicating the prompt)
  const revealEl = document.getElementById("quizReveal");
  if (revealEl) {
    const en = q.target?.word || "";
    const ja = q.target?.meaning || "";
    if (q.mode === "ja2en") {
      // Prompt already shows Japanese meaning; reveal only the English word to avoid duplication.
      revealEl.innerHTML = en ? `<div class="quiz-reveal-word">${escapeHtml(en)}</div>` : "";
    } else {
      // en2ja: reveal both English + Japanese
      if (en || ja) {
        revealEl.innerHTML = `
          <div class="quiz-reveal-word">${escapeHtml(en)}</div>
          <div class="quiz-reveal-meaning">${escapeHtml(ja)}</div>
        `;
      } else {
        revealEl.textContent = "";
      }
    }
  }

  // 日→英：解答後のみ、各選択肢の下に日本語訳を表示
  if (q.mode === "ja2en") {
    const btns = Array.from(document.querySelectorAll(".choice-btn"));
    btns.forEach((b) => {
      const sub = b.querySelector(".choice-sub");
      if (!sub) return;
      const ja = sub.getAttribute("data-ja") || "";
      sub.textContent = ja;
    });
  }

  // mark buttons
  const btns = Array.from(document.querySelectorAll(".choice-btn"));
  btns.forEach((b) => {
    const choice = b.dataset.choice || "";
    if (choice === q.correct) b.classList.add("correct");
    if (choice === selected && !isCorrect) b.classList.add("wrong");
    b.disabled = true;
  });

  // footer actions
  const footEl = document.getElementById("quizFoot");
  if (footEl) {
    const msg = document.createElement("div");
    msg.className = "quiz-mini";
    msg.style.marginTop = "6px";
    // Avoid showing the correct answer text redundantly; it's revealed in the main reveal area.
    msg.textContent = isCorrect ? "正解！" : "不正解";
    footEl.appendChild(msg);

    const actions = document.createElement("div");
    actions.style.display = "flex";
    actions.style.gap = "8px";
    actions.style.alignItems = "center";
    actions.style.flexWrap = "wrap";
    actions.style.marginTop = "10px";

    const speakBtn = document.createElement("button");
    speakBtn.className = "small-btn";
    speakBtn.textContent = "🔊 発音";
    speakBtn.addEventListener("click", () => q.target.word && speak(q.target.word));

    const markForgot = document.createElement("button");
    markForgot.className = "small-btn danger";
    markForgot.textContent = "覚えてないへ";
    markForgot.addEventListener("click", () => updateWordStatus(q.target.id, "forgot"));

    const markLearned = document.createElement("button");
    markLearned.className = "small-btn accent";
    markLearned.textContent = "覚えたへ";
    markLearned.addEventListener("click", () => updateWordStatus(q.target.id, "learned"));

    actions.appendChild(speakBtn);
    actions.appendChild(markForgot);
    actions.appendChild(markLearned);
    footEl.appendChild(actions);
  }

  const score = document.getElementById("scorePill");
  if (score) score.textContent = `${quizState.correct} / ${quizState.total}`;

  const nextBtn = document.getElementById("nextQuizBtn");
  if (nextBtn) nextBtn.disabled = false;
}

function updateWordStatus(id, status) {
  const all = loadWords();
  const idx = all.findIndex(w => w.id === id);
  if (idx >= 0) {
    all[idx].status = status;
    saveWords(all);
    // update label in footer
    const footEl = document.getElementById("quizFoot");
    if (footEl && quizState.current) {
      const lbl = STATUS_LABEL[status] || status;
      const info = footEl.querySelector(".quiz-mini");
      if (info) info.textContent = `出題元カテゴリ: ${lbl}`;
    }
  }
}

function nextQuestion() {
  const mode = document.getElementById("quizMode")?.value || "en2ja";
  const pool = document.getElementById("quizPool")?.value || "all";
  quizState.current = buildQuestion(mode, pool);
  quizState.answered = false;
  quizState.active = true;
  renderQuiz();
}

function setupQuiz() {
  const startBtn = document.getElementById("startQuizBtn");
  const nextBtn = document.getElementById("nextQuizBtn");
  if (!startBtn || !nextBtn) return;

  startBtn.addEventListener("click", () => {
    quizState.active = true;
    quizState.current = null;
    quizState.answered = false;
    // keep score (or reset?). Better to reset on new start.
    quizState.correct = 0;
    quizState.total = 0;

    // Reset quiz deck to avoid carrying order across sessions
    quizDeckState.key = "";
    quizDeckState.order = [];
    quizDeckState.idx = 0;
    nextQuestion();
  });

  nextBtn.addEventListener("click", () => {
    nextQuestion();
  });
}


function normalizeImportedItem(x) {
  if (!x || typeof x !== "object") return null;
  const word = String(x.word || "").trim();
  const meaning = String(x.meaning || "").trim();
  if (!word || !meaning) return null;
  return {
    id: String(x.id || `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`),
    word,
    meaning,
    status: (x.status === "forgot" || x.status === "default" || x.status === "learned") ? x.status : "default",
    example: String(x.example || "").trim(),
    memo: String(x.memo || "").trim(),
    tags: String(x.tags || "").trim(),
    synonyms: String(x.synonyms || "").trim(),
    source: String(x.source || "import"),
    createdAt: String(x.createdAt || new Date().toISOString()),
  };
}

function setupImport() {
  const btn = document.getElementById("importBtn");
  const file = document.getElementById("importFile");
  if (!btn || !file) return;

  btn.addEventListener("click", () => file.click());

  file.addEventListener("change", async () => {
    const f = file.files && file.files[0];
    file.value = ""; // allow re-importing same file
    if (!f) return;

    try {
      const text = await f.text();
      const parsed = JSON.parse(text);
      const arr = Array.isArray(parsed) ? parsed : (Array.isArray(parsed.words) ? parsed.words : null);
      if (!arr) throw new Error("JSON形式が不正です（配列を期待）。");

      const incoming = arr.map(normalizeImportedItem).filter(Boolean);
      if (incoming.length === 0) throw new Error("取り込める単語がありません（word/meaning必須）。");

      const current = loadWords();

      // Merge: prefer id, fallback to (word|meaning)
      const byId = new Map(current.map(w => [w.id, w]));
      const byKey = new Map(current.map(w => [`${(w.word||"").toLowerCase()}|${w.meaning||""}`, w]));

      let added = 0;
      for (const w of incoming) {
        const key = `${w.word.toLowerCase()}|${w.meaning}`;
        if (byId.has(w.id)) continue;
        if (byKey.has(key)) continue;

        current.push(w);
        byId.set(w.id, w);
        byKey.set(key, w);
        added += 1;
      }

      // ✅ Always persist immediately after upload/import
      saveWords(current);
      renderWordList();
      setListMsg(`Import完了：${added}件 追加しました（重複はスキップ）。`);
    } catch (e) {
      setListMsg(String(e.message || e), "err");
    }
  });
}


document.addEventListener("DOMContentLoaded", () => {
  // Prime iOS audio + voices with the first user gesture (no UI changes)
  const __primeOnce = () => {
    __unlockAudioOnce();
    __primeHtmlAudioOnce();
    __loadVoices();
  };
  ["pointerdown","touchstart","mousedown","keydown"].forEach((ev) => {
    document.addEventListener(ev, __primeOnce, { once: true, passive: true });
  });
  try {
    window.speechSynthesis?.addEventListener?.("voiceschanged", __loadVoices);
    // Some iOS versions don't fire voiceschanged reliably; try again shortly.
    setTimeout(__loadVoices, 250);
  } catch(e) {}

  setupTabs();
  setupSettings();
  setupAddForm();
  applyIncomingWordToAddForm();
  setupFilter();
  setupSort();
  setupTagFilter();
  setupExport();
  setupImport();
  setupQuiz();
  setupFortune();

  renderWordList();
  renderQuiz();
});

// ============================================================================
// Fortune (EN) × TANGO-CHO  —  100% Horoscope-inspired engine
// - Uses approximate planetary positions (JPL Keplerian elements, valid 1800-2050)
// - Geocentric ecliptic longitudes from heliocentric vectors (planet - Earth)
// - Moon longitude via simplified SunCalc-style formula
// - Score blends "slow background" and "fast wave" to keep the 100% feel
// - Text generation is seeded + anti-repetition (per category)
// - Tap a word => send to Add tab
// ============================================================================

const FORTUNE_KEY = "tangoChoFortune";
const FORTUNE_HISTORY_KEY = "tangoChoFortuneHistory";

function setupFortune(){
  const birthEl = document.getElementById("fortuneBirth");
  const dateEl = document.getElementById("fortuneDate");
  const levelEl = document.getElementById("fortuneLevel");
  const genBtn = document.getElementById("fortuneGenBtn");
  const outEl = document.getElementById("fortuneResults");
  if (!birthEl || !dateEl || !levelEl || !genBtn || !outEl) return;

  // defaults
  const today = new Date();
  dateEl.value = toDateInputValue(today);

  // restore
  try {
    const raw = localStorage.getItem(FORTUNE_KEY);
    if (raw) {
      const s = JSON.parse(raw);
      if (s?.birth) birthEl.value = s.birth;
      if (s?.date) dateEl.value = s.date;
      if (s?.level) levelEl.value = s.level;
    }
  } catch(_) {}


// Back-date prevention: ignore previously saved target date on startup; always start from "today".
// (The user can still change the date manually; changes are persisted via the change listener.)
try { dateEl.value = toDateInputValue(new Date()); } catch(_) {}

  function persist(){
    try {
      localStorage.setItem(FORTUNE_KEY, JSON.stringify({
        birth: birthEl.value,
        date: dateEl.value,
        level: levelEl.value,
      }));
    } catch(_) {}
  }


  // Auto-select English level from study progress (unless user has explicitly chosen)
  try{
    if (!localStorage.getItem(FORTUNE_MANUAL_KEY)) {
      levelEl.value = capToFortuneLevel(getDifficultyCap());
      persist();
    }
  }catch(_){}

  birthEl.addEventListener("change", persist);
  dateEl.addEventListener("change", persist);
  levelEl.addEventListener("change", () => {
    try{ localStorage.setItem(FORTUNE_MANUAL_KEY, "1"); }catch(_){}
    persist();
  });

  genBtn.addEventListener("click", () => {
    // default target date to today only if empty (user can change freely)
    try { if (!dateEl.value) dateEl.value = toDateInputValue(new Date()); } catch(_) {}
    const birth = birthEl.value;
    const date = dateEl.value;
    if (!birth) {
      alert("誕生日（Birth date）を入力してください");
      return;
    }
    if (!date) {
      alert("日付（Target date）を入力してください");
      return;
    }

    try {
      const result = fortuneGenerate({
        birthDate: birth,
        targetDate: date,
        level: levelEl.value,
        tone: "clean",
      });
      renderFortune(result, outEl, null);
      persist();
    } catch(e) {
      console.error(e);
      alert("生成に失敗しました。もう一度お試しください。");
    }
  });

  // auto-generate once if birth already set
  if (birthEl.value) genBtn.click();
}

function toDateInputValue(d){
  const tz = d.getTimezoneOffset();
  const local = new Date(d.getTime() - tz*60000);
  return local.toISOString().slice(0,10);
}

// -------------------- RNG + hash --------------------
function fnv1a32(str){
  let h = 0x811c9dc5;
  for (let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 0x01000193);
  }
  return h >>> 0;
}
function mulberry32(seed){
  let a = seed >>> 0;
  return function(){
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

// -------------------- Julian day helpers --------------------
function dateToJd(date){
  // date: JS Date in UTC
  const y = date.getUTCFullYear();
  const m = date.getUTCMonth() + 1;
  const d = date.getUTCDate() + (date.getUTCHours() + (date.getUTCMinutes() + date.getUTCSeconds()/60)/60)/24;
  let A = Math.floor((14 - m)/12);
  let Y = y + 4800 - A;
  let M = m + 12*A - 3;
  let JDN = d + Math.floor((153*M + 2)/5) + 365*Y + Math.floor(Y/4) - Math.floor(Y/100) + Math.floor(Y/400) - 32045;
  return JDN;
}
function isoToUtcDate(iso){
  const [Y,M,D] = iso.split("-").map(n=>parseInt(n,10));
  return new Date(Date.UTC(Y, M-1, D, 0,0,0));
}

// -------------------- Orbital mechanics (JPL elements) --------------------
// Source: NASA/JPL SSD "Approximate Positions of the Planets" (Table 1, 1800-2050)
// https://ssd.jpl.nasa.gov/planets/approx_pos.html
// (we only use a,e,I,L,long.peri,long.node + rates; b,c,s,f terms omitted)
const JPL_ELEMS = {
  mercury: {a0:0.38709927, a1:0.00000037, e0:0.20563593, e1:0.00001906, I0:7.00497902, I1:-0.00594749, L0:252.25032350, L1:149472.67411175, wbar0:77.45779628, wbar1:0.16047689, Om0:48.33076593, Om1:-0.12534081},
  venus:   {a0:0.72333566, a1:0.00000390, e0:0.00677672, e1:-0.00004107, I0:3.39467605, I1:-0.00078890, L0:181.97909950, L1:58517.81538729, wbar0:131.60246718, wbar1:0.00268329, Om0:76.67984255, Om1:-0.27769418},
  earth:   {a0:1.00000261, a1:0.00000562, e0:0.01671123, e1:-0.00004392, I0:-0.00001531, I1:-0.01294668, L0:100.46457166, L1:35999.37244981, wbar0:102.93768193, wbar1:0.32327364, Om0:0.0, Om1:0.0},
  mars:    {a0:1.52371034, a1:0.00001847, e0:0.09339410, e1:0.00007882, I0:1.84969142, I1:-0.00813131, L0:-4.55343205, L1:19140.30268499, wbar0:-23.94362959, wbar1:0.44441088, Om0:49.55953891, Om1:-0.29257343},
  jupiter: {a0:5.20288700, a1:-0.00011607, e0:0.04838624, e1:-0.00013253, I0:1.30439695, I1:-0.00183714, L0:34.39644051, L1:3034.74612775, wbar0:14.72847983, wbar1:0.21252668, Om0:100.47390909, Om1:0.20469106},
  saturn:  {a0:9.53667594, a1:-0.00125060, e0:0.05386179, e1:-0.00050991, I0:2.48599187, I1:0.00193609, L0:49.95424423, L1:1222.49362201, wbar0:92.59887831, wbar1:-0.41897216, Om0:113.66242448, Om1:-0.28867794},
};

function degToRad(d){return d*Math.PI/180;}
function radToDeg(r){return r*180/Math.PI;}
function normDeg(d){d%=360; if(d<0)d+=360; return d;}
function wrapSignedDeg(d){d%=360; if(d>180)d-=360; if(d<-180)d+=360; return d;}

function keplerSolveE(M, e){
  // M in radians
  let E = M + e*Math.sin(M);
  for (let i=0;i<7;i++){
    const f = E - e*Math.sin(E) - M;
    const fp = 1 - e*Math.cos(E);
    const dE = f/fp;
    E -= dE;
    if (Math.abs(dE) < 1e-10) break;
  }
  return E;
}

function planetHelioEclVec(body, jd){
  const el = JPL_ELEMS[body];
  if (!el) throw new Error("unknown body: " + body);
  const T = (jd - 2451545.0)/36525.0;
  const a = el.a0 + el.a1*T;
  const e = el.e0 + el.e1*T;
  const I = degToRad(el.I0 + el.I1*T);
  const L = degToRad(el.L0 + el.L1*T);
  const wbar = degToRad(el.wbar0 + el.wbar1*T);
  const Om = degToRad(el.Om0 + el.Om1*T);
  const w = wbar - Om;
  let M = L - wbar; // radians
  // normalize to [-pi,pi]
  M = Math.atan2(Math.sin(M), Math.cos(M));
  const E = keplerSolveE(M, e);
  const xprime = a*(Math.cos(E) - e);
  const yprime = a*Math.sqrt(1 - e*e)*Math.sin(E);

  const cosw = Math.cos(w), sinw = Math.sin(w);
  const cosO = Math.cos(Om), sinO = Math.sin(Om);
  const cosI = Math.cos(I), sinI = Math.sin(I);

  // Rotate: Rz(-Om) Rx(-I) Rz(-w) applied to r'  (matching JPL expression)
  // JPL provides direct matrix with +; we use equivalent formulation for r_ecl.
  const x = (cosw*cosO - sinw*sinO*cosI)*xprime + (-sinw*cosO - cosw*sinO*cosI)*yprime;
  const y = (cosw*sinO + sinw*cosO*cosI)*xprime + (-sinw*sinO + cosw*cosO*cosI)*yprime;
  const z = (sinw*sinI)*xprime + (cosw*sinI)*yprime;
  return {x,y,z};
}

function eclLonFromVec(v){
  return normDeg(radToDeg(Math.atan2(v.y, v.x)));
}

function geoEclLon(body, jd){
  if (body === "sun"){
    // Sun geocentric longitude is opposite of Earth's heliocentric longitude
    const e = planetHelioEclVec("earth", jd);
    return normDeg(eclLonFromVec({x:-e.x,y:-e.y,z:-e.z}));
  }
  if (body === "moon") return moonGeoLon(jd);
  const p = planetHelioEclVec(body, jd);
  const e = planetHelioEclVec("earth", jd);
  const g = {x:p.x - e.x, y:p.y - e.y, z:p.z - e.z};
  return eclLonFromVec(g);
}

// Moon longitude approximation (SunCalc-style)
function moonGeoLon(jd){
  const d = jd - 2451545.0; // days since J2000
  const rad = Math.PI/180;
  const L = rad*(218.316 + 13.176396*d);
  const M = rad*(134.963 + 13.064993*d);
  // longitude (deg): l = L + 6.289 sin M
  const l = L + rad*6.289*Math.sin(M);
  return normDeg(radToDeg(l));
}

// -------------------- Score model --------------------
const CAT = [
  {id:"overall", name:"Overall"},
  {id:"love", name:"Love"},
  {id:"work", name:"Work"},
  {id:"money", name:"Money"},
  {id:"health", name:"Health"},
];

const PLANETS_BG = ["saturn","jupiter","mars"]; // slow-ish
const PLANETS_WV = ["moon","sun","venus","mercury"]; // fast-ish

function aspectScore(deltaDeg){
  const peaks = [
    {a:0, w:1.00},
    {a:60, w:0.65},
    {a:120, w:0.90},
    {a:90, w:-0.70},
    {a:180, w:-1.00},
    {a:270, w:-0.60},
    {a:240, w:0.55},
    {a:300, w:0.55},
  ];
  const s = 12; // degrees
  let num = 0;
  let den = 0;
  for (const p of peaks){
    const d = wrapSignedDeg(deltaDeg - p.a);
    const g = Math.exp(-(d*d)/(2*s*s));
    num += p.w*g;
    den += Math.abs(p.w)*g;
  }
  if (!den) return 0;
  return Math.max(-1, Math.min(1, num/den));
}

function scoreAt(jdTarget, lonBirth){
  let bg = 0, wv = 0;
  for (const b of PLANETS_BG){
    const d = normDeg(geoEclLon(b, jdTarget) - lonBirth[b]);
    bg += aspectScore(d);
  }
  bg /= PLANETS_BG.length;

  for (const p of PLANETS_WV){
    const d = normDeg(geoEclLon(p, jdTarget) - lonBirth[p]);
    wv += aspectScore(d);
  }
  wv /= PLANETS_WV.length;

  // blend fast wave + slow background
  return 0.58*wv + 0.42*bg;
}

function blendedScore(jdTarget, lonBirth){
  // "100%" feel: a local (±16d) and a seasonal (±90d) component
  const s0 = scoreAt(jdTarget, lonBirth);
  const s16 = (scoreAt(jdTarget-16, lonBirth) + s0 + scoreAt(jdTarget+16, lonBirth))/3;
  const s90 = (scoreAt(jdTarget-90, lonBirth) + s0 + scoreAt(jdTarget+90, lonBirth))/3;
  const s = 0.70*s16 + 0.30*s90;
  return Math.max(-1, Math.min(1, s));
}

function scoreToPercent(s){
  // tanh mapping => stays away from hard 0/100 unless very strong
  const p = 50 + 50*Math.tanh(1.35*s);
  return Math.round(Math.max(0, Math.min(100, p)));
}

function bandFromPercent(p){
  if (p >= 85) return "great";
  if (p >= 65) return "good";
  if (p >= 45) return "neutral";
  if (p >= 25) return "low";
  return "rough";
}

function fortuneGenerate({birthDate, targetDate, level, tone}){
  const seed = fnv1a32(`${birthDate}|${targetDate}|${level}|${tone}|fortune-v2`);
  const rng = mulberry32(seed);

  const jdBirth = dateToJd(isoToUtcDate(birthDate));
  const jdTarget = dateToJd(isoToUtcDate(targetDate));

  const lonBirth = {
    sun: geoEclLon("sun", jdBirth),
    moon: geoEclLon("moon", jdBirth),
    mercury: geoEclLon("mercury", jdBirth),
    venus: geoEclLon("venus", jdBirth),
    mars: geoEclLon("mars", jdBirth),
    jupiter: geoEclLon("jupiter", jdBirth),
    saturn: geoEclLon("saturn", jdBirth),
  };

  // Category weighting: each category leans on different mixes
  const mixes = {
    overall: {kWave:0.58, kSlow:0.42, tweak:0.00},
    love:    {kWave:0.65, kSlow:0.35, tweak:+0.04},
    work:    {kWave:0.50, kSlow:0.50, tweak:-0.02},
    money:   {kWave:0.46, kSlow:0.54, tweak:-0.01},
    health:  {kWave:0.55, kSlow:0.45, tweak:-0.03},
  };

  const items = [];
  for (const c of CAT){
    const m = mixes[c.id] || mixes.overall;
    const s0 = blendedScore(jdTarget, lonBirth);
    // small, deterministic category warp
    const jitter = (rng()-0.5)*0.08;
    const s = Math.max(-1, Math.min(1, s0 + m.tweak + jitter));
    const percent = scoreToPercent(s);
    const band = bandFromPercent(percent);
    // Use BANK_ENJA paired text when available (no API translation needed)
    const text = pickFortuneTextV2({rng, seed, cat:c.id, band, level, tone});
    items.push({
      id: c.id,
      title: c.name,
      percent,
      band,
      en: text.en,
      ja: (text && text.ja) ? text.ja : "",
      keyWords: text.keyWords,
    });
  }

  return {
    birthDate,
    targetDate,
    level,
    tone,
    seed,
    items,
  };
}

// -------------------- Text generation (seeded + anti-repeat) --------------------
// We generate sentences from parts to avoid obvious repetition.
// Key requirement: prioritize high-frequency TOEIC vocabulary.

const TOEIC_CORE = [
  "focus","priority","schedule","deadline","commitment","efficient","improve","maintain","balance","strategy","opportunity",
  "clarify","confirm","adjust","resource","quality","outcome","progress","support","challenge","steady","practical","reliable",
  "decision","communicate","negotiate","prepare","review","measure","feedback","initiative","confidence","responsibility","flexible",
  "notice","detail","consistent","estimate","assume","prevent","reduce","avoid","increase","secure","trust","respect",
];

function pick(arr, rng){ return arr[Math.floor(rng()*arr.length)]; }

function antiRepeatKey(cat){
  return `${FORTUNE_HISTORY_KEY}:${cat}`;
}

function loadHistory(cat){
  try {
    const raw = localStorage.getItem(antiRepeatKey(cat));
    const a = raw ? JSON.parse(raw) : [];
    return Array.isArray(a) ? a : [];
  } catch { return []; }
}

function saveHistory(cat, hist){
  try { localStorage.setItem(antiRepeatKey(cat), JSON.stringify(hist.slice(-40))); } catch(_) {}
}

function pickNonRepeating(candidates, cat, rng){
  const hist = loadHistory(cat);
  const recent = new Set(hist.slice(-10));
  const filtered = candidates.filter(x => !recent.has(x.id));
  const pool = filtered.length ? filtered : candidates;
  const chosen = pool[Math.floor(rng()*pool.length)];
  hist.push(chosen.id);
  saveHistory(cat, hist);
  return chosen;
}

// Cache a chosen item per deterministic context so repeated "Generate" taps
// return the exact same result. We still keep anti-repeat across *different*
// contexts/days by updating history only when a new context appears.
function cacheKeyForContext(ctx){
  return `${FORTUNE_HISTORY_KEY}:cache:${ctx}`;
}
function loadCachedChoice(ctx){
  try {
    const raw = localStorage.getItem(cacheKeyForContext(ctx));
    return raw ? String(raw) : "";
  } catch { return ""; }
}
function saveCachedChoice(ctx, id){
  try { localStorage.setItem(cacheKeyForContext(ctx), String(id || "")); } catch(_) {}
}

// -------------------- Text bank (EN+JA) --------------------
// Prefer BANK_ENJA (loaded via bank_enja.js). This avoids repeated phrasing and
// provides built-in JP for sentence-level translation.
function pickFortuneTextV2({rng, seed, cat, band, level, tone}){
  // Map 5 bands -> a/b/c tiers
  const tier = (band === "great" || band === "good") ? "a" : (band === "neutral" ? "b" : "c");
  const lvl = String(level || "adult");
  const c = String(cat || "overall");

  // If BANK_ENJA exists and has the category, use it.
  const bankRootAll = (typeof BANK_ENJA !== "undefined" && BANK_ENJA) ? BANK_ENJA : null;
  const bankRoot = bankRootAll && (bankRootAll[lvl] || bankRootAll.adult || bankRootAll);
  const byCat = bankRoot && (bankRoot[c] || bankRoot.overall);
  const arr = byCat && (byCat[tier] || byCat.b || byCat.a || byCat.c);

  if (Array.isArray(arr) && arr.length){
    const candidates = arr.map((x, i) => {
      const en = String(x.en || "").trim();
      const ja = String(x.ja || "").trim();
      const low = en.toLowerCase();
      const hits = TOEIC_CORE.filter(w => low.includes(w));
      const pool = hits.length ? hits : TOEIC_CORE;
      const k1 = pool[Math.floor(rng()*pool.length)];
      let k2 = pool[Math.floor(rng()*pool.length)];
      if (pool.length > 1) {
        let guard = 0;
        while (k2 === k1 && guard++ < 8) k2 = pool[Math.floor(rng()*pool.length)];
      }
      const id = `${lvl}_${c}_${tier}_${i}_${fnv1a32(en)}`;
      return { id, en, ja, keyWords: [k1, k2] };
    });

    // Make output stable: if the same context (same seed) is requested again,
    // return the exact same sentence.
    const ctx = `${seed}:${c}:${lvl}:${tier}`;
    const cachedId = loadCachedChoice(ctx);
    if (cachedId) {
      const hit = candidates.find(x => x.id === cachedId);
      if (hit) return hit;
    }

    const chosen = pickNonRepeating(candidates, `${c}:${lvl}:${tier}`, rng);
    saveCachedChoice(ctx, chosen.id);
    return chosen;
  }

  // Fallback to the procedural generator (older implementation)
  return pickFortuneText({rng, seed, cat:c, band, level:lvl, tone});
}



// -------------------- Render + interactions --------------------
function renderFortune(model, outEl, stateEl){
  outEl.innerHTML = "";
  for (const item of model.items){
    const wrap = document.createElement("div");
    wrap.className = "fortune-item";

    const head = document.createElement("div");
    head.className = "fortune-head";

    const title = document.createElement("div");
    title.className = "fortune-title";
    title.textContent = item.title;

    const meta = document.createElement("div");
    meta.className = "fortune-meta";
    const pill = document.createElement("div");
    pill.className = "fortune-pill";
    pill.textContent = `${item.percent}%`;
    const score = document.createElement("div");
    score.className = "fortune-score";
    score.textContent = `${model.targetDate} / ${model.level}`;
    meta.appendChild(pill);
    meta.appendChild(score);

    head.appendChild(title);
    head.appendChild(meta);

    const text = document.createElement("div");
    text.className = "fortune-text";
    text.innerHTML = wrapWords(item.en);

    const actions = document.createElement("div");
    actions.className = "fortune-actions";
    const btnTranslate = document.createElement("button");
    btnTranslate.className = "ghost-btn";
    btnTranslate.type = "button";
    btnTranslate.textContent = "JP";

    const jp = document.createElement("div");
    jp.className = "fortune-jp";
    jp.style.display = "none";

    btnTranslate.addEventListener("click", () => {
      if (jp.style.display !== "none") {
        jp.style.display = "none";
        btnTranslate.textContent = "JP";
        return;
      }
      const jptxt = String(item.ja || "").trim();
      if (!jptxt) {
        jp.textContent = "（日本語訳は次の拡張で増やします）";
      } else {
        jp.textContent = jptxt;
      }
      jp.style.display = "block";
      btnTranslate.textContent = "Hide JP";
    });
    actions.appendChild(btnTranslate);

    wrap.appendChild(head);
    wrap.appendChild(text);
    wrap.appendChild(actions);
    wrap.appendChild(jp);

    // word tap => send to Add tab
    wrap.addEventListener("click", (ev) => {
      const t = ev.target;
      if (!(t instanceof HTMLElement)) return;
      if (!t.classList.contains("w")) return;
      const w = (t.getAttribute("data-w") || "").trim();
      if (!w) return;
      sendWordToAdd(w);
    });

    outEl.appendChild(wrap);
  }
}

function wrapWords(text){
  // Keep punctuation, wrap words only
  return String(text).replace(/([A-Za-z][A-Za-z\-']*)/g, (m) => {
    const w = m;
    return `<span class="w" data-w="${escapeHtml(w)}">${escapeHtml(w)}</span>`;
  });
}

function escapeHtml(s){
  return String(s)
    .replace(/&/g,"&amp;")
    .replace(/</g,"&lt;")
    .replace(/>/g,"&gt;")
    .replace(/\"/g,"&quot;")
    .replace(/'/g,"&#39;");
}

function sendWordToAdd(word){
  const w = normalizeWordInput(word);
  if (!w) return;
  const input = document.getElementById("word");
  if (input) input.value = w;
  // move tab
  const addBtn = document.querySelector('.tab-button[data-section="addSection"]');
  if (addBtn) addBtn.click();
  // show a tiny message
  const msg = document.getElementById("msg");
  if (msg) {
    msg.textContent = `「${w}」を転送しました（翻訳ボタンで日本語化できます）`;
    msg.classList.add("ok");
    setTimeout(()=>{ msg.textContent = ""; msg.classList.remove("ok"); }, 2500);
  }
}